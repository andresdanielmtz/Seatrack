{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n/**\n * @module ol/TileQueue\n */\nimport EventType from './events/EventType.js';\nimport PriorityQueue, { DROP } from './structs/PriorityQueue.js';\nimport TileState from './TileState.js';\n\n/**\n * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\n */\nvar TileQueue = /*#__PURE__*/function (_PriorityQueue) {\n  _inherits(TileQueue, _PriorityQueue);\n  /**\n   * @param {PriorityFunction} tilePriorityFunction Tile priority function.\n   * @param {function(): ?} tileChangeCallback Function called on each tile change event.\n   */\n  function TileQueue(tilePriorityFunction, tileChangeCallback) {\n    var _this;\n    _classCallCheck(this, TileQueue);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TileQueue).call(this,\n    /**\n     * @param {Array} element Element.\n     * @return {number} Priority.\n     */\n    function (element) {\n      return tilePriorityFunction.apply(null, element);\n    },\n    /**\n     * @param {Array} element Element.\n     * @return {string} Key.\n     */\n    function (element) {\n      return (/** @type {import(\"./Tile.js\").default} */element[0].getKey()\n      );\n    }));\n\n    /** @private */\n    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    /**\n     * @private\n     * @type {function(): ?}\n     */\n    _this.tileChangeCallback_ = tileChangeCallback;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.tilesLoading_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string,boolean>}\n     */\n    _this.tilesLoadingKeys_ = {};\n    return _this;\n  }\n\n  /**\n   * @param {Array} element Element.\n   * @return {boolean} The element was added to the queue.\n   */\n  _createClass(TileQueue, [{\n    key: \"enqueue\",\n    value: function enqueue(element) {\n      var added = _get(_getPrototypeOf(TileQueue.prototype), \"enqueue\", this).call(this, element);\n      if (added) {\n        var tile = element[0];\n        tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n      }\n      return added;\n    }\n    /**\n     * @return {number} Number of tiles loading.\n     */\n  }, {\n    key: \"getTilesLoading\",\n    value: function getTilesLoading() {\n      return this.tilesLoading_;\n    }\n    /**\n     * @param {import(\"./events/Event.js\").default} event Event.\n     * @protected\n     */\n  }, {\n    key: \"handleTileChange\",\n    value: function handleTileChange(event) {\n      var tile = /** @type {import(\"./Tile.js\").default} */event.target;\n      var state = tile.getState();\n      if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {\n        if (state !== TileState.ERROR) {\n          tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n        }\n        var tileKey = tile.getKey();\n        if (tileKey in this.tilesLoadingKeys_) {\n          delete this.tilesLoadingKeys_[tileKey];\n          --this.tilesLoading_;\n        }\n        this.tileChangeCallback_();\n      }\n    }\n    /**\n     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n     * @param {number} maxNewLoads Maximum number of new tiles to load.\n     */\n  }, {\n    key: \"loadMoreTiles\",\n    value: function loadMoreTiles(maxTotalLoading, maxNewLoads) {\n      var newLoads = 0;\n      var state, tile, tileKey;\n      while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {\n        tile = /** @type {import(\"./Tile.js\").default} */this.dequeue()[0];\n        tileKey = tile.getKey();\n        state = tile.getState();\n        if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n          this.tilesLoadingKeys_[tileKey] = true;\n          ++this.tilesLoading_;\n          ++newLoads;\n          tile.load();\n        }\n      }\n    }\n  }]);\n  return TileQueue;\n}(PriorityQueue);\nexport default TileQueue;\n\n/**\n * @param {import('./Map.js').FrameState} frameState Frame state.\n * @param {import(\"./Tile.js\").default} tile Tile.\n * @param {string} tileSourceKey Tile source key.\n * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n * @param {number} tileResolution Tile resolution.\n * @return {number} Tile priority.\n */\nexport function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {\n  // Filter out tiles at higher zoom levels than the current zoom level, or that\n  // are outside the visible extent.\n  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n    return DROP;\n  }\n  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n    return DROP;\n  }\n  // Prioritize the highest zoom level tiles closest to the focus.\n  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n  // Within a zoom level, tiles are prioritized by the distance in pixels between\n  // the center of the tile and the center of the viewport.  The factor of 65536\n  // means that the prioritization should behave as desired for tiles up to\n  // 65536 * Math.log(2) = 45426 pixels from the focus.\n  var center = frameState.viewState.center;\n  var deltaX = tileCenter[0] - center[0];\n  var deltaY = tileCenter[1] - center[1];\n  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport { VOID } from '../functions.js';\nimport { clear } from '../obj.js';\n\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nvar Target = /*#__PURE__*/function (_Disposable) {\n  _inherits(Target, _Disposable);\n  /**\n   * @param {*} [target] Default event target for dispatched events.\n   */\n  function Target(target) {\n    var _this;\n    _classCallCheck(this, Target);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Target).call(this));\n\n    /**\n     * @private\n     * @type {*}\n     */\n    _this.eventTarget_ = target;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    _this.pendingRemovals_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    _this.dispatching_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>}\n     */\n    _this.listeners_ = null;\n    return _this;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  _createClass(Target, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener) {\n      if (!type || !listener) {\n        return;\n      }\n      var listeners = this.listeners_ || (this.listeners_ = {});\n      var listenersForType = listeners[type] || (listeners[type] = []);\n      if (!listenersForType.includes(listener)) {\n        listenersForType.push(listener);\n      }\n    }\n    /**\n     * Dispatches an event and calls all listeners listening for events\n     * of this type. The event parameter can either be a string or an\n     * Object with a `type` property.\n     *\n     * @param {import(\"./Event.js\").default|string} event Event object.\n     * @return {boolean|undefined} `false` if anyone called preventDefault on the\n     *     event object or if any of the listeners returned false.\n     * @api\n     */\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      var isString = typeof event === 'string';\n      var type = isString ? event : event.type;\n      var listeners = this.listeners_ && this.listeners_[type];\n      if (!listeners) {\n        return;\n      }\n      var evt = isString ? new Event(event) : /** @type {Event} */event;\n      if (!evt.target) {\n        evt.target = this.eventTarget_ || this;\n      }\n      var dispatching = this.dispatching_ || (this.dispatching_ = {});\n      var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});\n      if (!(type in dispatching)) {\n        dispatching[type] = 0;\n        pendingRemovals[type] = 0;\n      }\n      ++dispatching[type];\n      var propagate;\n      for (var i = 0, ii = listeners.length; i < ii; ++i) {\n        if ('handleEvent' in listeners[i]) {\n          propagate = /** @type {import(\"../events.js\").ListenerObject} */listeners[i].handleEvent(evt);\n        } else {\n          propagate = /** @type {import(\"../events.js\").ListenerFunction} */listeners[i].call(this, evt);\n        }\n        if (propagate === false || evt.propagationStopped) {\n          propagate = false;\n          break;\n        }\n      }\n      if (--dispatching[type] === 0) {\n        var pr = pendingRemovals[type];\n        delete pendingRemovals[type];\n        while (pr--) {\n          this.removeEventListener(type, VOID);\n        }\n        delete dispatching[type];\n      }\n      return propagate;\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"disposeInternal\",\n    value: function disposeInternal() {\n      this.listeners_ && clear(this.listeners_);\n    }\n    /**\n     * Get the listeners for a specified event type. Listeners are returned in the\n     * order that they will be called in.\n     *\n     * @param {string} type Type.\n     * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n     */\n  }, {\n    key: \"getListeners\",\n    value: function getListeners(type) {\n      return this.listeners_ && this.listeners_[type] || undefined;\n    }\n    /**\n     * @param {string} [type] Type. If not provided,\n     *     `true` will be returned if this event target has any listeners.\n     * @return {boolean} Has listeners.\n     */\n  }, {\n    key: \"hasListener\",\n    value: function hasListener(type) {\n      if (!this.listeners_) {\n        return false;\n      }\n      return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n    }\n    /**\n     * @param {string} type Type.\n     * @param {import(\"../events.js\").Listener} listener Listener.\n     */\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, listener) {\n      var listeners = this.listeners_ && this.listeners_[type];\n      if (listeners) {\n        var index = listeners.indexOf(listener);\n        if (index !== -1) {\n          if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n            // make listener a no-op, and remove later in #dispatchEvent()\n            listeners[index] = VOID;\n            ++this.pendingRemovals_[type];\n          } else {\n            listeners.splice(index, 1);\n            if (listeners.length === 0) {\n              delete this.listeners_[type];\n            }\n          }\n        }\n      }\n    }\n  }]);\n  return Target;\n}(Disposable);\nexport default Target;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/interaction/DragPan\n */\nimport PointerInteraction, { centroid as centroidFromPointers } from './Pointer.js';\nimport { FALSE } from '../functions.js';\nimport { all, focusWithTabindex, noModifierKeys, primaryAction } from '../events/condition.js';\nimport { easeOut } from '../easing.js';\nimport { rotate as rotateCoordinate, scale as scaleCoordinate } from '../coordinate.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\nvar DragPan = /*#__PURE__*/function (_PointerInteraction) {\n  _inherits(DragPan, _PointerInteraction);\n  /**\n   * @param {Options} [options] Options.\n   */\n  function DragPan(options) {\n    var _this;\n    _classCallCheck(this, DragPan);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DragPan).call(this, {\n      stopDown: FALSE\n    }));\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../Kinetic.js\").default|undefined}\n     */\n    _this.kinetic_ = options.kinetic;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     */\n    _this.lastCentroid = null;\n\n    /**\n     * @type {number}\n     */\n    _this.lastPointersCount_;\n\n    /**\n     * @type {boolean}\n     */\n    _this.panning_ = false;\n    var condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    _this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.noKinetic_ = false;\n    return _this;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  _createClass(DragPan, [{\n    key: \"handleDragEvent\",\n    value: function handleDragEvent(mapBrowserEvent) {\n      var map = mapBrowserEvent.map;\n      if (!this.panning_) {\n        this.panning_ = true;\n        map.getView().beginInteraction();\n      }\n      var targetPointers = this.targetPointers;\n      var centroid = map.getEventPixel(centroidFromPointers(targetPointers));\n      if (targetPointers.length == this.lastPointersCount_) {\n        if (this.kinetic_) {\n          this.kinetic_.update(centroid[0], centroid[1]);\n        }\n        if (this.lastCentroid) {\n          var delta = [this.lastCentroid[0] - centroid[0], centroid[1] - this.lastCentroid[1]];\n          var _map = mapBrowserEvent.map;\n          var view = _map.getView();\n          scaleCoordinate(delta, view.getResolution());\n          rotateCoordinate(delta, view.getRotation());\n          view.adjustCenterInternal(delta);\n        }\n      } else if (this.kinetic_) {\n        // reset so we don't overestimate the kinetic energy after\n        // after one finger down, tiny drag, second finger down\n        this.kinetic_.begin();\n      }\n      this.lastCentroid = centroid;\n      this.lastPointersCount_ = targetPointers.length;\n      mapBrowserEvent.originalEvent.preventDefault();\n    }\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n     * @return {boolean} If the event was consumed.\n     */\n  }, {\n    key: \"handleUpEvent\",\n    value: function handleUpEvent(mapBrowserEvent) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      if (this.targetPointers.length === 0) {\n        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n          var distance = this.kinetic_.getDistance();\n          var angle = this.kinetic_.getAngle();\n          var center = view.getCenterInternal();\n          var centerpx = map.getPixelFromCoordinateInternal(center);\n          var dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);\n          view.animateInternal({\n            center: view.getConstrainedCenter(dest),\n            duration: 500,\n            easing: easeOut\n          });\n        }\n        if (this.panning_) {\n          this.panning_ = false;\n          view.endInteraction();\n        }\n        return false;\n      }\n      if (this.kinetic_) {\n        // reset so we don't overestimate the kinetic energy after\n        // after one finger up, tiny drag, second finger up\n        this.kinetic_.begin();\n      }\n      this.lastCentroid = null;\n      return true;\n    }\n    /**\n     * Handle pointer down events.\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n     * @return {boolean} If the event was consumed.\n     */\n  }, {\n    key: \"handleDownEvent\",\n    value: function handleDownEvent(mapBrowserEvent) {\n      if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        this.lastCentroid = null;\n        // stop any current animation\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        if (this.kinetic_) {\n          this.kinetic_.begin();\n        }\n        // No kinetic as soon as more than one pointer on the screen is\n        // detected. This is to prevent nasty pans after pinch.\n        this.noKinetic_ = this.targetPointers.length > 1;\n        return true;\n      }\n      return false;\n    }\n  }]);\n  return DragPan;\n}(PointerInteraction);\nexport default DragPan;","map":null,"metadata":{},"sourceType":"module"}
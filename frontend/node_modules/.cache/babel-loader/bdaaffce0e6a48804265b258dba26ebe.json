{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/style/RegularShape\n */\n\nimport ImageState from '../ImageState.js';\nimport ImageStyle from './Image.js';\nimport { asArray } from '../color.js';\nimport { asColorLike } from '../colorlike.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { defaultFillStyle, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../render/canvas.js';\n\n/**\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\n * @typedef {Object} Options\n * @property {import(\"./Fill.js\").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} [radius] Radius of a regular polygon.\n * @property {number} [radius1] First radius of a star. Ignored if radius is set.\n * @property {number} [radius2] Second radius of a star.\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.\n * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.\n * Positive values will shift the shape right and up.\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {number|import(\"../size.js\").Size} [scale=1] Scale. Unless two dimensional scaling is required a better\n * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.\n * @property {\"declutter\"|\"obstacle\"|\"none\"|undefined} [declutterMode] Declutter mode.\n */\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import(\"../colorlike.js\").ColorLike} [strokeStyle] StrokeStyle.\n * @property {number} strokeWidth StrokeWidth.\n * @property {number} size Size.\n * @property {Array<number>|null} lineDash LineDash.\n * @property {number} lineDashOffset LineDashOffset.\n * @property {CanvasLineJoin} lineJoin LineJoin.\n * @property {number} miterLimit MiterLimit.\n */\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n * @api\n */\nvar RegularShape = /*#__PURE__*/function (_ImageStyle) {\n  _inherits(RegularShape, _ImageStyle);\n  /**\n   * @param {Options} options Options.\n   */\n  function RegularShape(options) {\n    var _this;\n    _classCallCheck(this, RegularShape);\n    /**\n     * @type {boolean}\n     */\n    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RegularShape).call(this, {\n      opacity: 1,\n      rotateWithView: rotateWithView,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: options.scale !== undefined ? options.scale : 1,\n      displacement: options.displacement !== undefined ? options.displacement : [0, 0],\n      declutterMode: options.declutterMode\n    }));\n\n    /**\n     * @private\n     * @type {Object<number, HTMLCanvasElement>}\n     */\n    _this.canvas_ = undefined;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.hitDetectionCanvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default}\n     */\n    _this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    _this.origin_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.points_ = options.points;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.radius_ = options.radius !== undefined ? options.radius : options.radius1;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    _this.radius2_ = options.radius2;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default}\n     */\n    _this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    _this.size_ = null;\n\n    /**\n     * @private\n     * @type {RenderOptions}\n     */\n    _this.renderOptions_ = null;\n    _this.render();\n    return _this;\n  }\n\n  /**\n   * Clones the style.\n   * @return {RegularShape} The cloned style.\n   * @api\n   */\n  _createClass(RegularShape, [{\n    key: \"clone\",\n    value: function clone() {\n      var scale = this.getScale();\n      var style = new RegularShape({\n        fill: this.getFill() ? this.getFill().clone() : undefined,\n        points: this.getPoints(),\n        radius: this.getRadius(),\n        radius2: this.getRadius2(),\n        angle: this.getAngle(),\n        stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n        rotation: this.getRotation(),\n        rotateWithView: this.getRotateWithView(),\n        scale: Array.isArray(scale) ? scale.slice() : scale,\n        displacement: this.getDisplacement().slice(),\n        declutterMode: this.getDeclutterMode()\n      });\n      style.setOpacity(this.getOpacity());\n      return style;\n    }\n    /**\n     * Get the anchor point in pixels. The anchor determines the center point for the\n     * symbolizer.\n     * @return {Array<number>} Anchor.\n     * @api\n     */\n  }, {\n    key: \"getAnchor\",\n    value: function getAnchor() {\n      var size = this.size_;\n      if (!size) {\n        return null;\n      }\n      var displacement = this.getDisplacement();\n      var scale = this.getScaleArray();\n      // anchor is scaled by renderer but displacement should not be scaled\n      // so divide by scale here\n      return [size[0] / 2 - displacement[0] / scale[0], size[1] / 2 + displacement[1] / scale[1]];\n    }\n    /**\n     * Get the angle used in generating the shape.\n     * @return {number} Shape's rotation in radians.\n     * @api\n     */\n  }, {\n    key: \"getAngle\",\n    value: function getAngle() {\n      return this.angle_;\n    }\n    /**\n     * Get the fill style for the shape.\n     * @return {import(\"./Fill.js\").default} Fill style.\n     * @api\n     */\n  }, {\n    key: \"getFill\",\n    value: function getFill() {\n      return this.fill_;\n    }\n    /**\n     * Set the fill style.\n     * @param {import(\"./Fill.js\").default} fill Fill style.\n     * @api\n     */\n  }, {\n    key: \"setFill\",\n    value: function setFill(fill) {\n      this.fill_ = fill;\n      this.render();\n    }\n    /**\n     * @return {HTMLCanvasElement} Image element.\n     */\n  }, {\n    key: \"getHitDetectionImage\",\n    value: function getHitDetectionImage() {\n      if (!this.hitDetectionCanvas_) {\n        this.createHitDetectionCanvas_(this.renderOptions_);\n      }\n      return this.hitDetectionCanvas_;\n    }\n    /**\n     * Get the image icon.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {HTMLCanvasElement} Image or Canvas element.\n     * @api\n     */\n  }, {\n    key: \"getImage\",\n    value: function getImage(pixelRatio) {\n      var image = this.canvas_[pixelRatio];\n      if (!image) {\n        var renderOptions = this.renderOptions_;\n        var context = createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);\n        this.draw_(renderOptions, context, pixelRatio);\n        image = context.canvas;\n        this.canvas_[pixelRatio] = image;\n      }\n      return image;\n    }\n    /**\n     * Get the image pixel ratio.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Pixel ratio.\n     */\n  }, {\n    key: \"getPixelRatio\",\n    value: function getPixelRatio(pixelRatio) {\n      return pixelRatio;\n    }\n    /**\n     * @return {import(\"../size.js\").Size} Image size.\n     */\n  }, {\n    key: \"getImageSize\",\n    value: function getImageSize() {\n      return this.size_;\n    }\n    /**\n     * @return {import(\"../ImageState.js\").default} Image state.\n     */\n  }, {\n    key: \"getImageState\",\n    value: function getImageState() {\n      return ImageState.LOADED;\n    }\n    /**\n     * Get the origin of the symbolizer.\n     * @return {Array<number>} Origin.\n     * @api\n     */\n  }, {\n    key: \"getOrigin\",\n    value: function getOrigin() {\n      return this.origin_;\n    }\n    /**\n     * Get the number of points for generating the shape.\n     * @return {number} Number of points for stars and regular polygons.\n     * @api\n     */\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      return this.points_;\n    }\n    /**\n     * Get the (primary) radius for the shape.\n     * @return {number} Radius.\n     * @api\n     */\n  }, {\n    key: \"getRadius\",\n    value: function getRadius() {\n      return this.radius_;\n    }\n    /**\n     * Get the secondary radius for the shape.\n     * @return {number|undefined} Radius2.\n     * @api\n     */\n  }, {\n    key: \"getRadius2\",\n    value: function getRadius2() {\n      return this.radius2_;\n    }\n    /**\n     * Get the size of the symbolizer (in pixels).\n     * @return {import(\"../size.js\").Size} Size.\n     * @api\n     */\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return this.size_;\n    }\n    /**\n     * Get the stroke style for the shape.\n     * @return {import(\"./Stroke.js\").default} Stroke style.\n     * @api\n     */\n  }, {\n    key: \"getStroke\",\n    value: function getStroke() {\n      return this.stroke_;\n    }\n    /**\n     * Set the stroke style.\n     * @param {import(\"./Stroke.js\").default} stroke Stroke style.\n     * @api\n     */\n  }, {\n    key: \"setStroke\",\n    value: function setStroke(stroke) {\n      this.stroke_ = stroke;\n      this.render();\n    }\n    /**\n     * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n     */\n  }, {\n    key: \"listenImageChange\",\n    value: function listenImageChange(listener) {}\n    /**\n     * Load not yet loaded URI.\n     */\n  }, {\n    key: \"load\",\n    value: function load() {}\n    /**\n     * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n     */\n  }, {\n    key: \"unlistenImageChange\",\n    value: function unlistenImageChange(listener) {}\n    /**\n     * Calculate additional canvas size needed for the miter.\n     * @param {string} lineJoin Line join\n     * @param {number} strokeWidth Stroke width\n     * @param {number} miterLimit Miter limit\n     * @return {number} Additional canvas size needed\n     * @private\n     */\n  }, {\n    key: \"calculateLineJoinSize_\",\n    value: function calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {\n      if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== 'bevel' && lineJoin !== 'miter') {\n        return strokeWidth;\n      }\n      // m  | ^\n      // i  | |\\                  .\n      // t >|  #\\\n      // e  | |\\ \\              .\n      // r      \\s\\\n      //      |  \\t\\          .                 .\n      //          \\r\\                      .   .\n      //      |    \\o\\      .          .  . . .\n      //          e \\k\\            .  .    . .\n      //      |      \\e\\  .    .  .       . .\n      //       d      \\ \\  .  .          . .\n      //      | _ _a_ _\\#  .            . .\n      //   r1          / `             . .\n      //      |                       . .\n      //       b     /               . .\n      //      |                     . .\n      //           / r2            . .\n      //      |                        .   .\n      //         /                           .   .\n      //      |α                                   .   .\n      //       /                                         .   .\n      //      ° center\n      var r1 = this.radius_;\n      var r2 = this.radius2_ === undefined ? r1 : this.radius2_;\n      if (r1 < r2) {\n        var tmp = r1;\n        r1 = r2;\n        r2 = tmp;\n      }\n      var points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;\n      var alpha = 2 * Math.PI / points;\n      var a = r2 * Math.sin(alpha);\n      var b = Math.sqrt(r2 * r2 - a * a);\n      var d = r1 - b;\n      var e = Math.sqrt(a * a + d * d);\n      var miterRatio = e / a;\n      if (lineJoin === 'miter' && miterRatio <= miterLimit) {\n        return miterRatio * strokeWidth;\n      }\n      // Calculate the distnce from center to the stroke corner where\n      // it was cut short because of the miter limit.\n      //              l\n      //        ----+---- <= distance from center to here is maxr\n      //       /####|k ##\\\n      //      /#####^#####\\\n      //     /#### /+\\# s #\\\n      //    /### h/+++\\# t #\\\n      //   /### t/+++++\\# r #\\\n      //  /### a/+++++++\\# o #\\\n      // /### p/++ fill +\\# k #\\\n      ///#### /+++++^+++++\\# e #\\\n      //#####/+++++/+\\+++++\\#####\\\n      var k = strokeWidth / 2 / miterRatio;\n      var l = strokeWidth / 2 * (d / e);\n      var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);\n      var bevelAdd = maxr - r1;\n      if (this.radius2_ === undefined || lineJoin === 'bevel') {\n        return bevelAdd * 2;\n      }\n      // If outer miter is over the miter limit the inner miter may reach through the\n      // center and be longer than the bevel, same calculation as above but swap r1 / r2.\n      var aa = r1 * Math.sin(alpha);\n      var bb = Math.sqrt(r1 * r1 - aa * aa);\n      var dd = r2 - bb;\n      var ee = Math.sqrt(aa * aa + dd * dd);\n      var innerMiterRatio = ee / aa;\n      if (innerMiterRatio <= miterLimit) {\n        var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;\n        return 2 * Math.max(bevelAdd, innerLength);\n      }\n      return bevelAdd * 2;\n    }\n    /**\n     * @return {RenderOptions}  The render options\n     * @protected\n     */\n  }, {\n    key: \"createRenderOptions\",\n    value: function createRenderOptions() {\n      var lineJoin = defaultLineJoin;\n      var miterLimit = 0;\n      var lineDash = null;\n      var lineDashOffset = 0;\n      var strokeStyle;\n      var strokeWidth = 0;\n      if (this.stroke_) {\n        strokeStyle = this.stroke_.getColor();\n        if (strokeStyle === null) {\n          strokeStyle = defaultStrokeStyle;\n        }\n        strokeStyle = asColorLike(strokeStyle);\n        strokeWidth = this.stroke_.getWidth();\n        if (strokeWidth === undefined) {\n          strokeWidth = defaultLineWidth;\n        }\n        lineDash = this.stroke_.getLineDash();\n        lineDashOffset = this.stroke_.getLineDashOffset();\n        lineJoin = this.stroke_.getLineJoin();\n        if (lineJoin === undefined) {\n          lineJoin = defaultLineJoin;\n        }\n        miterLimit = this.stroke_.getMiterLimit();\n        if (miterLimit === undefined) {\n          miterLimit = defaultMiterLimit;\n        }\n      }\n      var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);\n      var maxRadius = Math.max(this.radius_, this.radius2_ || 0);\n      var size = Math.ceil(2 * maxRadius + add);\n      return {\n        strokeStyle: strokeStyle,\n        strokeWidth: strokeWidth,\n        size: size,\n        lineDash: lineDash,\n        lineDashOffset: lineDashOffset,\n        lineJoin: lineJoin,\n        miterLimit: miterLimit\n      };\n    }\n    /**\n     * @protected\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.renderOptions_ = this.createRenderOptions();\n      var size = this.renderOptions_.size;\n      this.canvas_ = {};\n      this.size_ = [size, size];\n    }\n    /**\n     * @private\n     * @param {RenderOptions} renderOptions Render options.\n     * @param {CanvasRenderingContext2D} context The rendering context.\n     * @param {number} pixelRatio The pixel ratio.\n     */\n  }, {\n    key: \"draw_\",\n    value: function draw_(renderOptions, context, pixelRatio) {\n      context.scale(pixelRatio, pixelRatio);\n      // set origin to canvas center\n      context.translate(renderOptions.size / 2, renderOptions.size / 2);\n      this.createPath_(context);\n      if (this.fill_) {\n        var color = this.fill_.getColor();\n        if (color === null) {\n          color = defaultFillStyle;\n        }\n        context.fillStyle = asColorLike(color);\n        context.fill();\n      }\n      if (this.stroke_) {\n        context.strokeStyle = renderOptions.strokeStyle;\n        context.lineWidth = renderOptions.strokeWidth;\n        if (renderOptions.lineDash) {\n          context.setLineDash(renderOptions.lineDash);\n          context.lineDashOffset = renderOptions.lineDashOffset;\n        }\n        context.lineJoin = renderOptions.lineJoin;\n        context.miterLimit = renderOptions.miterLimit;\n        context.stroke();\n      }\n    }\n    /**\n     * @private\n     * @param {RenderOptions} renderOptions Render options.\n     */\n  }, {\n    key: \"createHitDetectionCanvas_\",\n    value: function createHitDetectionCanvas_(renderOptions) {\n      if (this.fill_) {\n        var color = this.fill_.getColor();\n\n        // determine if fill is transparent (or pattern or gradient)\n        var opacity = 0;\n        if (typeof color === 'string') {\n          color = asArray(color);\n        }\n        if (color === null) {\n          opacity = 1;\n        } else if (Array.isArray(color)) {\n          opacity = color.length === 4 ? color[3] : 1;\n        }\n        if (opacity === 0) {\n          // if a transparent fill style is set, create an extra hit-detection image\n          // with a default fill style\n          var context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n          this.hitDetectionCanvas_ = context.canvas;\n          this.drawHitDetectionCanvas_(renderOptions, context);\n        }\n      }\n      if (!this.hitDetectionCanvas_) {\n        this.hitDetectionCanvas_ = this.getImage(1);\n      }\n    }\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context The context to draw in.\n     */\n  }, {\n    key: \"createPath_\",\n    value: function createPath_(context) {\n      var points = this.points_;\n      var radius = this.radius_;\n      if (points === Infinity) {\n        context.arc(0, 0, radius, 0, 2 * Math.PI);\n      } else {\n        var radius2 = this.radius2_ === undefined ? radius : this.radius2_;\n        if (this.radius2_ !== undefined) {\n          points *= 2;\n        }\n        var startAngle = this.angle_ - Math.PI / 2;\n        var step = 2 * Math.PI / points;\n        for (var i = 0; i < points; i++) {\n          var angle0 = startAngle + i * step;\n          var radiusC = i % 2 === 0 ? radius : radius2;\n          context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));\n        }\n        context.closePath();\n      }\n    }\n    /**\n     * @private\n     * @param {RenderOptions} renderOptions Render options.\n     * @param {CanvasRenderingContext2D} context The context.\n     */\n  }, {\n    key: \"drawHitDetectionCanvas_\",\n    value: function drawHitDetectionCanvas_(renderOptions, context) {\n      // set origin to canvas center\n      context.translate(renderOptions.size / 2, renderOptions.size / 2);\n      this.createPath_(context);\n      context.fillStyle = defaultFillStyle;\n      context.fill();\n      if (this.stroke_) {\n        context.strokeStyle = renderOptions.strokeStyle;\n        context.lineWidth = renderOptions.strokeWidth;\n        if (renderOptions.lineDash) {\n          context.setLineDash(renderOptions.lineDash);\n          context.lineDashOffset = renderOptions.lineDashOffset;\n        }\n        context.lineJoin = renderOptions.lineJoin;\n        context.miterLimit = renderOptions.miterLimit;\n        context.stroke();\n      }\n    }\n  }]);\n  return RegularShape;\n}(ImageStyle);\nexport default RegularShape;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport { abstract } from '../util.js';\nimport { createOrUpdateFromFlatCoordinates, getCenter } from '../extent.js';\nimport { rotate as _rotate, scale as _scale, transform2D, translate as _translate } from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nvar SimpleGeometry = /*#__PURE__*/function (_Geometry) {\n  _inherits(SimpleGeometry, _Geometry);\n  function SimpleGeometry() {\n    var _this;\n    _classCallCheck(this, SimpleGeometry);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SimpleGeometry).call(this));\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    _this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    _this.flatCoordinates = null;\n    return _this;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  _createClass(SimpleGeometry, [{\n    key: \"computeExtent\",\n    value: function computeExtent(extent) {\n      return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    }\n    /**\n     * @abstract\n     * @return {Array<*> | null} Coordinates.\n     */\n  }, {\n    key: \"getCoordinates\",\n    value: function getCoordinates() {\n      return abstract();\n    }\n    /**\n     * Return the first coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n     * @api\n     */\n  }, {\n    key: \"getFirstCoordinate\",\n    value: function getFirstCoordinate() {\n      return this.flatCoordinates.slice(0, this.stride);\n    }\n    /**\n     * @return {Array<number>} Flat coordinates.\n     */\n  }, {\n    key: \"getFlatCoordinates\",\n    value: function getFlatCoordinates() {\n      return this.flatCoordinates;\n    }\n    /**\n     * Return the last coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} Last point.\n     * @api\n     */\n  }, {\n    key: \"getLastCoordinate\",\n    value: function getLastCoordinate() {\n      return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n    }\n    /**\n     * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n     * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n     * @api\n     */\n  }, {\n    key: \"getLayout\",\n    value: function getLayout() {\n      return this.layout;\n    }\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     */\n  }, {\n    key: \"getSimplifiedGeometry\",\n    value: function getSimplifiedGeometry(squaredTolerance) {\n      if (this.simplifiedGeometryRevision !== this.getRevision()) {\n        this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n        this.simplifiedGeometryRevision = this.getRevision();\n      }\n      // If squaredTolerance is negative or if we know that simplification will not\n      // have any effect then just return this.\n      if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {\n        return this;\n      }\n      var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n        return simplifiedGeometry;\n      }\n      // Simplification did not actually remove any coordinates.  We now know\n      // that any calls to getSimplifiedGeometry with a squaredTolerance less\n      // than or equal to the current squaredTolerance will also not have any\n      // effect.  This allows us to short circuit simplification (saving CPU\n      // cycles) and prevents the cache of simplified geometries from filling\n      // up with useless identical copies of this geometry (saving memory).\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     * @protected\n     */\n  }, {\n    key: \"getSimplifiedGeometryInternal\",\n    value: function getSimplifiedGeometryInternal(squaredTolerance) {\n      return this;\n    }\n    /**\n     * @return {number} Stride.\n     */\n  }, {\n    key: \"getStride\",\n    value: function getStride() {\n      return this.stride;\n    }\n    /**\n     * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     */\n  }, {\n    key: \"setFlatCoordinates\",\n    value: function setFlatCoordinates(layout, flatCoordinates) {\n      this.stride = getStrideForLayout(layout);\n      this.layout = layout;\n      this.flatCoordinates = flatCoordinates;\n    }\n    /**\n     * @abstract\n     * @param {!Array<*>} coordinates Coordinates.\n     * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n     */\n  }, {\n    key: \"setCoordinates\",\n    value: function setCoordinates(coordinates, layout) {\n      abstract();\n    }\n    /**\n     * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n     * @param {Array<*>} coordinates Coordinates.\n     * @param {number} nesting Nesting.\n     * @protected\n     */\n  }, {\n    key: \"setLayout\",\n    value: function setLayout(layout, coordinates, nesting) {\n      /** @type {number} */\n      var stride;\n      if (layout) {\n        stride = getStrideForLayout(layout);\n      } else {\n        for (var i = 0; i < nesting; ++i) {\n          if (coordinates.length === 0) {\n            this.layout = 'XY';\n            this.stride = 2;\n            return;\n          }\n          coordinates = /** @type {Array} */coordinates[0];\n        }\n        stride = coordinates.length;\n        layout = getLayoutForStride(stride);\n      }\n      this.layout = layout;\n      this.stride = stride;\n    }\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     * @api\n     */\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform(transformFn) {\n      if (this.flatCoordinates) {\n        transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n        this.changed();\n      }\n    }\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, anchor) {\n      var flatCoordinates = this.getFlatCoordinates();\n      if (flatCoordinates) {\n        var stride = this.getStride();\n        _rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n        this.changed();\n      }\n    }\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, anchor) {\n      if (sy === undefined) {\n        sy = sx;\n      }\n      if (!anchor) {\n        anchor = getCenter(this.getExtent());\n      }\n      var flatCoordinates = this.getFlatCoordinates();\n      if (flatCoordinates) {\n        var stride = this.getStride();\n        _scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n        this.changed();\n      }\n    }\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n  }, {\n    key: \"translate\",\n    value: function translate(deltaX, deltaY) {\n      var flatCoordinates = this.getFlatCoordinates();\n      if (flatCoordinates) {\n        var stride = this.getStride();\n        _translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n        this.changed();\n      }\n    }\n  }]);\n  return SimpleGeometry;\n}(Geometry);\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  var layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return (/** @type {import(\"./Geometry.js\").GeometryLayout} */layout\n  );\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  var stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return (/** @type {number} */stride\n  );\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  var flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  var stride = simpleGeometry.getStride();\n  return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, dest);\n}\nexport default SimpleGeometry;","map":null,"metadata":{},"sourceType":"module"}
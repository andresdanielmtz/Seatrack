{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/render/canvas/TextBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction from './Instruction.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { defaultFillStyle, defaultFont, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultPadding, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, registerFont } from '../canvas.js';\nimport { getUid } from '../../util.js';\nimport { intersects } from '../../extent.js';\nimport { matchingChunk } from '../../geom/flat/straightchunk.js';\n/**\n * @const\n * @enum {number}\n */\nexport var TEXT_ALIGN = {\n  'left': 0,\n  'end': 0,\n  'center': 0.5,\n  'right': 1,\n  'start': 1,\n  'top': 0,\n  'middle': 0.5,\n  'hanging': 0.2,\n  'alphabetic': 0.8,\n  'ideographic': 0.8,\n  'bottom': 1\n};\nvar CanvasTextBuilder = /*#__PURE__*/function (_CanvasBuilder) {\n  _inherits(CanvasTextBuilder, _CanvasBuilder);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this;\n    _classCallCheck(this, CanvasTextBuilder);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasTextBuilder).call(this, tolerance, maxExtent, resolution, pixelRatio));\n\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n    _this.labels_ = null;\n\n    /**\n     * @private\n     * @type {string|Array<string>}\n     */\n    _this.text_ = '';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textOffsetX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textOffsetY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    _this.textRotateWithView_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textRotation_ = 0;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    _this.textFillState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    _this.fillStates = {};\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    _this.textStrokeState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    _this.strokeStates = {};\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n    _this.textState_ = /** @type {import(\"../canvas.js\").TextState} */{};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    _this.textStates = {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.textKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.fillKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.strokeKey_ = '';\n\n    /**\n     * Data shared with an image builder for combined decluttering.\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterImageWithText}\n     */\n    _this.declutterImageWithText_ = undefined;\n    return _this;\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  _createClass(CanvasTextBuilder, [{\n    key: \"finish\",\n    value: function finish() {\n      var instructions = _get(_getPrototypeOf(CanvasTextBuilder.prototype), \"finish\", this).call(this);\n      instructions.textStates = this.textStates;\n      instructions.fillStates = this.fillStates;\n      instructions.strokeStates = this.strokeStates;\n      return instructions;\n    }\n    /**\n     * @param {import(\"../../geom/SimpleGeometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n  }, {\n    key: \"drawText\",\n    value: function drawText(geometry, feature) {\n      var fillState = this.textFillState_;\n      var strokeState = this.textStrokeState_;\n      var textState = this.textState_;\n      if (this.text_ === '' || !textState || !fillState && !strokeState) {\n        return;\n      }\n      var coordinates = this.coordinates;\n      var begin = coordinates.length;\n      var geometryType = geometry.getType();\n      var flatCoordinates = null;\n      var stride = geometry.getStride();\n      if (textState.placement === 'line' && (geometryType == 'LineString' || geometryType == 'MultiLineString' || geometryType == 'Polygon' || geometryType == 'MultiPolygon')) {\n        if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n          return;\n        }\n        var ends;\n        flatCoordinates = geometry.getFlatCoordinates();\n        if (geometryType == 'LineString') {\n          ends = [flatCoordinates.length];\n        } else if (geometryType == 'MultiLineString') {\n          ends = /** @type {import(\"../../geom/MultiLineString.js\").default} */geometry.getEnds();\n        } else if (geometryType == 'Polygon') {\n          ends = /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getEnds().slice(0, 1);\n        } else if (geometryType == 'MultiPolygon') {\n          var endss = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getEndss();\n          ends = [];\n          for (var i = 0, ii = endss.length; i < ii; ++i) {\n            ends.push(endss[i][0]);\n          }\n        }\n        this.beginGeometry(geometry, feature);\n        var textAlign = textState.textAlign;\n        // No `justify` support for line placement.\n        var flatOffset = 0;\n        var flatEnd;\n        for (var o = 0, oo = ends.length; o < oo; ++o) {\n          if (textAlign == undefined) {\n            var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n            flatOffset = range[0];\n            flatEnd = range[1];\n          } else {\n            flatEnd = ends[o];\n          }\n          for (var _i = flatOffset; _i < flatEnd; _i += stride) {\n            coordinates.push(flatCoordinates[_i], flatCoordinates[_i + 1]);\n          }\n          var end = coordinates.length;\n          flatOffset = ends[o];\n          this.drawChars_(begin, end);\n          begin = end;\n        }\n        this.endGeometry(feature);\n      } else {\n        var geometryWidths = textState.overflow ? null : [];\n        switch (geometryType) {\n          case 'Point':\n          case 'MultiPoint':\n            flatCoordinates = /** @type {import(\"../../geom/MultiPoint.js\").default} */geometry.getFlatCoordinates();\n            break;\n          case 'LineString':\n            flatCoordinates = /** @type {import(\"../../geom/LineString.js\").default} */geometry.getFlatMidpoint();\n            break;\n          case 'Circle':\n            flatCoordinates = /** @type {import(\"../../geom/Circle.js\").default} */geometry.getCenter();\n            break;\n          case 'MultiLineString':\n            flatCoordinates = /** @type {import(\"../../geom/MultiLineString.js\").default} */geometry.getFlatMidpoints();\n            stride = 2;\n            break;\n          case 'Polygon':\n            flatCoordinates = /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getFlatInteriorPoint();\n            if (!textState.overflow) {\n              geometryWidths.push(flatCoordinates[2] / this.resolution);\n            }\n            stride = 3;\n            break;\n          case 'MultiPolygon':\n            var interiorPoints = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getFlatInteriorPoints();\n            flatCoordinates = [];\n            for (var _i2 = 0, _ii = interiorPoints.length; _i2 < _ii; _i2 += 3) {\n              if (!textState.overflow) {\n                geometryWidths.push(interiorPoints[_i2 + 2] / this.resolution);\n              }\n              flatCoordinates.push(interiorPoints[_i2], interiorPoints[_i2 + 1]);\n            }\n            if (flatCoordinates.length === 0) {\n              return;\n            }\n            stride = 2;\n            break;\n          default:\n        }\n        var _end = this.appendFlatPointCoordinates(flatCoordinates, stride);\n        if (_end === begin) {\n          return;\n        }\n        if (geometryWidths && (_end - begin) / 2 !== flatCoordinates.length / stride) {\n          var beg = begin / 2;\n          geometryWidths = geometryWidths.filter(function (w, i) {\n            var keep = coordinates[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];\n            if (!keep) {\n              --beg;\n            }\n            return keep;\n          });\n        }\n        this.saveTextStates_();\n        if (textState.backgroundFill || textState.backgroundStroke) {\n          this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n          if (textState.backgroundFill) {\n            this.updateFillStyle(this.state, this.createFill);\n            this.hitDetectionInstructions.push(this.createFill(this.state));\n          }\n          if (textState.backgroundStroke) {\n            this.updateStrokeStyle(this.state, this.applyStroke);\n            this.hitDetectionInstructions.push(this.createStroke(this.state));\n          }\n        }\n        this.beginGeometry(geometry, feature);\n\n        // adjust padding for negative scale\n        var padding = textState.padding;\n        if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {\n          var p0 = textState.padding[0];\n          var p1 = textState.padding[1];\n          var p2 = textState.padding[2];\n          var p3 = textState.padding[3];\n          if (textState.scale[0] < 0) {\n            p1 = -p1;\n            p3 = -p3;\n          }\n          if (textState.scale[1] < 0) {\n            p0 = -p0;\n            p2 = -p2;\n          }\n          padding = [p0, p1, p2, p3];\n        }\n\n        // The image is unknown at this stage so we pass null; it will be computed at render time.\n        // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at\n        // render time.\n        var pixelRatio = this.pixelRatio;\n        this.instructions.push([CanvasInstruction.DRAW_IMAGE, begin, _end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, undefined, this.declutterImageWithText_, padding == defaultPadding ? defaultPadding : padding.map(function (p) {\n          return p * pixelRatio;\n        }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);\n        var scale = 1 / pixelRatio;\n        this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, begin, _end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [scale, scale], NaN, undefined, this.declutterImageWithText_, padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);\n        this.endGeometry(feature);\n      }\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"saveTextStates_\",\n    value: function saveTextStates_() {\n      var strokeState = this.textStrokeState_;\n      var textState = this.textState_;\n      var fillState = this.textFillState_;\n      var strokeKey = this.strokeKey_;\n      if (strokeState) {\n        if (!(strokeKey in this.strokeStates)) {\n          this.strokeStates[strokeKey] = {\n            strokeStyle: strokeState.strokeStyle,\n            lineCap: strokeState.lineCap,\n            lineDashOffset: strokeState.lineDashOffset,\n            lineWidth: strokeState.lineWidth,\n            lineJoin: strokeState.lineJoin,\n            miterLimit: strokeState.miterLimit,\n            lineDash: strokeState.lineDash\n          };\n        }\n      }\n      var textKey = this.textKey_;\n      if (!(textKey in this.textStates)) {\n        this.textStates[textKey] = {\n          font: textState.font,\n          textAlign: textState.textAlign || defaultTextAlign,\n          justify: textState.justify,\n          textBaseline: textState.textBaseline || defaultTextBaseline,\n          scale: textState.scale\n        };\n      }\n      var fillKey = this.fillKey_;\n      if (fillState) {\n        if (!(fillKey in this.fillStates)) {\n          this.fillStates[fillKey] = {\n            fillStyle: fillState.fillStyle\n          };\n        }\n      }\n    }\n    /**\n     * @private\n     * @param {number} begin Begin.\n     * @param {number} end End.\n     */\n  }, {\n    key: \"drawChars_\",\n    value: function drawChars_(begin, end) {\n      var strokeState = this.textStrokeState_;\n      var textState = this.textState_;\n      var strokeKey = this.strokeKey_;\n      var textKey = this.textKey_;\n      var fillKey = this.fillKey_;\n      this.saveTextStates_();\n      var pixelRatio = this.pixelRatio;\n      var baseline = TEXT_ALIGN[textState.textBaseline];\n      var offsetY = this.textOffsetY_ * pixelRatio;\n      var text = this.text_;\n      var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;\n      this.instructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);\n      this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, 1, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);\n    }\n    /**\n     * @param {import(\"../../style/Text.js\").default} textStyle Text style.\n     * @param {Object} [sharedData] Shared data.\n     */\n  }, {\n    key: \"setTextStyle\",\n    value: function setTextStyle(textStyle, sharedData) {\n      var textState, fillState, strokeState;\n      if (!textStyle) {\n        this.text_ = '';\n      } else {\n        var textFillStyle = textStyle.getFill();\n        if (!textFillStyle) {\n          fillState = null;\n          this.textFillState_ = fillState;\n        } else {\n          fillState = this.textFillState_;\n          if (!fillState) {\n            fillState = /** @type {import(\"../canvas.js\").FillState} */{};\n            this.textFillState_ = fillState;\n          }\n          fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);\n        }\n        var textStrokeStyle = textStyle.getStroke();\n        if (!textStrokeStyle) {\n          strokeState = null;\n          this.textStrokeState_ = strokeState;\n        } else {\n          strokeState = this.textStrokeState_;\n          if (!strokeState) {\n            strokeState = /** @type {import(\"../canvas.js\").StrokeState} */{};\n            this.textStrokeState_ = strokeState;\n          }\n          var lineDash = textStrokeStyle.getLineDash();\n          var lineDashOffset = textStrokeStyle.getLineDashOffset();\n          var lineWidth = textStrokeStyle.getWidth();\n          var miterLimit = textStrokeStyle.getMiterLimit();\n          strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n          strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n          strokeState.lineDashOffset = lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n          strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n          strokeState.lineWidth = lineWidth === undefined ? defaultLineWidth : lineWidth;\n          strokeState.miterLimit = miterLimit === undefined ? defaultMiterLimit : miterLimit;\n          strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);\n        }\n        textState = this.textState_;\n        var font = textStyle.getFont() || defaultFont;\n        registerFont(font);\n        var textScale = textStyle.getScaleArray();\n        textState.overflow = textStyle.getOverflow();\n        textState.font = font;\n        textState.maxAngle = textStyle.getMaxAngle();\n        textState.placement = textStyle.getPlacement();\n        textState.textAlign = textStyle.getTextAlign();\n        textState.justify = textStyle.getJustify();\n        textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n        textState.backgroundFill = textStyle.getBackgroundFill();\n        textState.backgroundStroke = textStyle.getBackgroundStroke();\n        textState.padding = textStyle.getPadding() || defaultPadding;\n        textState.scale = textScale === undefined ? [1, 1] : textScale;\n        var textOffsetX = textStyle.getOffsetX();\n        var textOffsetY = textStyle.getOffsetY();\n        var textRotateWithView = textStyle.getRotateWithView();\n        var textRotation = textStyle.getRotation();\n        this.text_ = textStyle.getText() || '';\n        this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n        this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n        this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n        this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n        this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';\n        this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.justify || '?') + (textState.textBaseline || '?');\n        this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + getUid(fillState.fillStyle) : '';\n      }\n      this.declutterImageWithText_ = sharedData;\n    }\n  }]);\n  return CanvasTextBuilder;\n}(CanvasBuilder);\nexport default CanvasTextBuilder;","map":null,"metadata":{},"sourceType":"module"}
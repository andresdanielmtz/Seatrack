{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/render/canvas/Immediate\n */\n// FIXME test, especially polygons with holes and multipolygons\n// FIXME need to handle large thick features (where pixel size matters)\n// FIXME add offset and end to ol/geom/flat/transform~transform2D?\n\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { defaultFillStyle, defaultFont, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline } from '../canvas.js';\nimport { equals } from '../../array.js';\nimport { intersects } from '../../extent.js';\nimport { toFixed } from '../../math.js';\nimport { transform2D } from '../../geom/flat/transform.js';\nimport { transformGeom2D } from '../../geom/SimpleGeometry.js';\n\n/**\n * @classdesc\n * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements\n * direct rendering of features and geometries to an HTML5 Canvas context.\n * Instances of this class are created internally by the library and\n * provided to application code as vectorContext member of the\n * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and\n * render events emitted by layers and maps.\n */\nvar CanvasImmediateRenderer = /*#__PURE__*/function (_VectorContext) {\n  _inherits(CanvasImmediateRenderer, _VectorContext);\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.\n   * @param {import(\"../../proj.js\").TransformFunction} [userTransform] Transform from user to view projection.\n   */\n  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, squaredTolerance, userTransform) {\n    var _this;\n    _classCallCheck(this, CanvasImmediateRenderer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasImmediateRenderer).call(this));\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    _this.context_ = context;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    _this.transform_ = transform;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.transformRotation_ = transform ? toFixed(Math.atan2(transform[1], transform[0]), 10) : 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.viewRotation_ = viewRotation;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.squaredTolerance_ = squaredTolerance;\n\n    /**\n     * @private\n     * @type {import(\"../../proj.js\").TransformFunction}\n     */\n    _this.userTransform_ = userTransform;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    _this.contextFillState_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    _this.contextStrokeState_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").TextState}\n     */\n    _this.contextTextState_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    _this.fillState_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    _this.strokeState_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}\n     */\n    _this.image_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.imageAnchorX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.imageAnchorY_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.imageHeight_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.imageOpacity_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.imageOriginX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.imageOriginY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.imageRotateWithView_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.imageRotation_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../../size.js\").Size}\n     */\n    _this.imageScale_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.imageWidth_ = 0;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.text_ = '';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textOffsetX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textOffsetY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.textRotateWithView_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.textRotation_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../../size.js\").Size}\n     */\n    _this.textScale_ = [0, 0];\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    _this.textFillState_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    _this.textStrokeState_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").TextState}\n     */\n    _this.textState_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    _this.pixelCoordinates_ = [];\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    _this.tmpLocalTransform_ = createTransform();\n    return _this;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   */\n  _createClass(CanvasImmediateRenderer, [{\n    key: \"drawImages_\",\n    value: function drawImages_(flatCoordinates, offset, end, stride) {\n      if (!this.image_) {\n        return;\n      }\n      var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);\n      var context = this.context_;\n      var localTransform = this.tmpLocalTransform_;\n      var alpha = context.globalAlpha;\n      if (this.imageOpacity_ != 1) {\n        context.globalAlpha = alpha * this.imageOpacity_;\n      }\n      var rotation = this.imageRotation_;\n      if (this.transformRotation_ === 0) {\n        rotation -= this.viewRotation_;\n      }\n      if (this.imageRotateWithView_) {\n        rotation += this.viewRotation_;\n      }\n      for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {\n        var x = pixelCoordinates[i] - this.imageAnchorX_;\n        var y = pixelCoordinates[i + 1] - this.imageAnchorY_;\n        if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {\n          var centerX = x + this.imageAnchorX_;\n          var centerY = y + this.imageAnchorY_;\n          composeTransform(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n          context.setTransform.apply(context, localTransform);\n          context.translate(centerX, centerY);\n          context.scale(this.imageScale_[0], this.imageScale_[1]);\n          context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);\n          context.setTransform(1, 0, 0, 1, 0, 0);\n        } else {\n          context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);\n        }\n      }\n      if (this.imageOpacity_ != 1) {\n        context.globalAlpha = alpha;\n      }\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @private\n     */\n  }, {\n    key: \"drawText_\",\n    value: function drawText_(flatCoordinates, offset, end, stride) {\n      if (!this.textState_ || this.text_ === '') {\n        return;\n      }\n      if (this.textFillState_) {\n        this.setContextFillState_(this.textFillState_);\n      }\n      if (this.textStrokeState_) {\n        this.setContextStrokeState_(this.textStrokeState_);\n      }\n      this.setContextTextState_(this.textState_);\n      var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);\n      var context = this.context_;\n      var rotation = this.textRotation_;\n      if (this.transformRotation_ === 0) {\n        rotation -= this.viewRotation_;\n      }\n      if (this.textRotateWithView_) {\n        rotation += this.viewRotation_;\n      }\n      for (; offset < end; offset += stride) {\n        var x = pixelCoordinates[offset] + this.textOffsetX_;\n        var y = pixelCoordinates[offset + 1] + this.textOffsetY_;\n        if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {\n          context.translate(x - this.textOffsetX_, y - this.textOffsetY_);\n          context.rotate(rotation);\n          context.translate(this.textOffsetX_, this.textOffsetY_);\n          context.scale(this.textScale_[0], this.textScale_[1]);\n          if (this.textStrokeState_) {\n            context.strokeText(this.text_, 0, 0);\n          }\n          if (this.textFillState_) {\n            context.fillText(this.text_, 0, 0);\n          }\n          context.setTransform(1, 0, 0, 1, 0, 0);\n        } else {\n          if (this.textStrokeState_) {\n            context.strokeText(this.text_, x, y);\n          }\n          if (this.textFillState_) {\n            context.fillText(this.text_, x, y);\n          }\n        }\n      }\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {boolean} close Close.\n     * @private\n     * @return {number} end End.\n     */\n  }, {\n    key: \"moveToLineTo_\",\n    value: function moveToLineTo_(flatCoordinates, offset, end, stride, close) {\n      var context = this.context_;\n      var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);\n      context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);\n      var length = pixelCoordinates.length;\n      if (close) {\n        length -= 2;\n      }\n      for (var i = 2; i < length; i += 2) {\n        context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);\n      }\n      if (close) {\n        context.closePath();\n      }\n      return end;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @private\n     * @return {number} End.\n     */\n  }, {\n    key: \"drawRings_\",\n    value: function drawRings_(flatCoordinates, offset, ends, stride) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);\n      }\n      return offset;\n    }\n    /**\n     * Render a circle geometry into the canvas.  Rendering is immediate and uses\n     * the current fill and stroke styles.\n     *\n     * @param {import(\"../../geom/Circle.js\").default} geometry Circle geometry.\n     * @api\n     */\n  }, {\n    key: \"drawCircle\",\n    value: function drawCircle(geometry) {\n      if (!intersects(this.extent_, geometry.getExtent())) {\n        return;\n      }\n      if (this.fillState_ || this.strokeState_) {\n        if (this.fillState_) {\n          this.setContextFillState_(this.fillState_);\n        }\n        if (this.strokeState_) {\n          this.setContextStrokeState_(this.strokeState_);\n        }\n        var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);\n        var dx = pixelCoordinates[2] - pixelCoordinates[0];\n        var dy = pixelCoordinates[3] - pixelCoordinates[1];\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        var context = this.context_;\n        context.beginPath();\n        context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);\n        if (this.fillState_) {\n          context.fill();\n        }\n        if (this.strokeState_) {\n          context.stroke();\n        }\n      }\n      if (this.text_ !== '') {\n        this.drawText_(geometry.getCenter(), 0, 2, 2);\n      }\n    }\n    /**\n     * Set the rendering style.  Note that since this is an immediate rendering API,\n     * any `zIndex` on the provided style will be ignored.\n     *\n     * @param {import(\"../../style/Style.js\").default} style The rendering style.\n     * @api\n     */\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(style) {\n      this.setFillStrokeStyle(style.getFill(), style.getStroke());\n      this.setImageStyle(style.getImage());\n      this.setTextStyle(style.getText());\n    }\n    /**\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     */\n  }, {\n    key: \"setTransform\",\n    value: function setTransform(transform) {\n      this.transform_ = transform;\n    }\n    /**\n     * Render a geometry into the canvas.  Call\n     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.\n     *\n     * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry The geometry to render.\n     * @api\n     */\n  }, {\n    key: \"drawGeometry\",\n    value: function drawGeometry(geometry) {\n      var type = geometry.getType();\n      switch (type) {\n        case 'Point':\n          this.drawPoint( /** @type {import(\"../../geom/Point.js\").default} */geometry);\n          break;\n        case 'LineString':\n          this.drawLineString( /** @type {import(\"../../geom/LineString.js\").default} */geometry);\n          break;\n        case 'Polygon':\n          this.drawPolygon( /** @type {import(\"../../geom/Polygon.js\").default} */geometry);\n          break;\n        case 'MultiPoint':\n          this.drawMultiPoint( /** @type {import(\"../../geom/MultiPoint.js\").default} */geometry);\n          break;\n        case 'MultiLineString':\n          this.drawMultiLineString( /** @type {import(\"../../geom/MultiLineString.js\").default} */\n          geometry);\n          break;\n        case 'MultiPolygon':\n          this.drawMultiPolygon( /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry);\n          break;\n        case 'GeometryCollection':\n          this.drawGeometryCollection( /** @type {import(\"../../geom/GeometryCollection.js\").default} */\n          geometry);\n          break;\n        case 'Circle':\n          this.drawCircle( /** @type {import(\"../../geom/Circle.js\").default} */geometry);\n          break;\n        default:\n      }\n    }\n    /**\n     * Render a feature into the canvas.  Note that any `zIndex` on the provided\n     * style will be ignored - features are rendered immediately in the order that\n     * this method is called.  If you need `zIndex` support, you should be using an\n     * {@link module:ol/layer/Vector~VectorLayer} instead.\n     *\n     * @param {import(\"../../Feature.js\").default} feature Feature.\n     * @param {import(\"../../style/Style.js\").default} style Style.\n     * @api\n     */\n  }, {\n    key: \"drawFeature\",\n    value: function drawFeature(feature, style) {\n      var geometry = style.getGeometryFunction()(feature);\n      if (!geometry || !intersects(this.extent_, geometry.getExtent())) {\n        return;\n      }\n      this.setStyle(style);\n      this.drawGeometry(geometry);\n    }\n    /**\n     * Render a GeometryCollection to the canvas.  Rendering is immediate and\n     * uses the current styles appropriate for each geometry in the collection.\n     *\n     * @param {import(\"../../geom/GeometryCollection.js\").default} geometry Geometry collection.\n     */\n  }, {\n    key: \"drawGeometryCollection\",\n    value: function drawGeometryCollection(geometry) {\n      var geometries = geometry.getGeometriesArray();\n      for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        this.drawGeometry(geometries[i]);\n      }\n    }\n    /**\n     * Render a Point geometry into the canvas.  Rendering is immediate and uses\n     * the current style.\n     *\n     * @param {import(\"../../geom/Point.js\").default|import(\"../Feature.js\").default} geometry Point geometry.\n     */\n  }, {\n    key: \"drawPoint\",\n    value: function drawPoint(geometry) {\n      if (this.squaredTolerance_) {\n        geometry = /** @type {import(\"../../geom/Point.js\").default} */\n        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n      }\n      var flatCoordinates = geometry.getFlatCoordinates();\n      var stride = geometry.getStride();\n      if (this.image_) {\n        this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n      }\n      if (this.text_ !== '') {\n        this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n      }\n    }\n    /**\n     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and\n     * uses the current style.\n     *\n     * @param {import(\"../../geom/MultiPoint.js\").default|import(\"../Feature.js\").default} geometry MultiPoint geometry.\n     */\n  }, {\n    key: \"drawMultiPoint\",\n    value: function drawMultiPoint(geometry) {\n      if (this.squaredTolerance_) {\n        geometry = /** @type {import(\"../../geom/MultiPoint.js\").default} */\n        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n      }\n      var flatCoordinates = geometry.getFlatCoordinates();\n      var stride = geometry.getStride();\n      if (this.image_) {\n        this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n      }\n      if (this.text_ !== '') {\n        this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n      }\n    }\n    /**\n     * Render a LineString into the canvas.  Rendering is immediate and uses\n     * the current style.\n     *\n     * @param {import(\"../../geom/LineString.js\").default|import(\"../Feature.js\").default} geometry LineString geometry.\n     */\n  }, {\n    key: \"drawLineString\",\n    value: function drawLineString(geometry) {\n      if (this.squaredTolerance_) {\n        geometry = /** @type {import(\"../../geom/LineString.js\").default} */\n        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n      }\n      if (!intersects(this.extent_, geometry.getExtent())) {\n        return;\n      }\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n        var context = this.context_;\n        var flatCoordinates = geometry.getFlatCoordinates();\n        context.beginPath();\n        this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);\n        context.stroke();\n      }\n      if (this.text_ !== '') {\n        var flatMidpoint = geometry.getFlatMidpoint();\n        this.drawText_(flatMidpoint, 0, 2, 2);\n      }\n    }\n    /**\n     * Render a MultiLineString geometry into the canvas.  Rendering is immediate\n     * and uses the current style.\n     *\n     * @param {import(\"../../geom/MultiLineString.js\").default|import(\"../Feature.js\").default} geometry MultiLineString geometry.\n     */\n  }, {\n    key: \"drawMultiLineString\",\n    value: function drawMultiLineString(geometry) {\n      if (this.squaredTolerance_) {\n        geometry = /** @type {import(\"../../geom/MultiLineString.js\").default} */\n        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n      }\n      var geometryExtent = geometry.getExtent();\n      if (!intersects(this.extent_, geometryExtent)) {\n        return;\n      }\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n        var context = this.context_;\n        var flatCoordinates = geometry.getFlatCoordinates();\n        var offset = 0;\n        var ends = /** @type {Array<number>} */geometry.getEnds();\n        var stride = geometry.getStride();\n        context.beginPath();\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);\n        }\n        context.stroke();\n      }\n      if (this.text_ !== '') {\n        var flatMidpoints = geometry.getFlatMidpoints();\n        this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);\n      }\n    }\n    /**\n     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses\n     * the current style.\n     *\n     * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} geometry Polygon geometry.\n     */\n  }, {\n    key: \"drawPolygon\",\n    value: function drawPolygon(geometry) {\n      if (this.squaredTolerance_) {\n        geometry = /** @type {import(\"../../geom/Polygon.js\").default} */\n        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n      }\n      if (!intersects(this.extent_, geometry.getExtent())) {\n        return;\n      }\n      if (this.strokeState_ || this.fillState_) {\n        if (this.fillState_) {\n          this.setContextFillState_(this.fillState_);\n        }\n        if (this.strokeState_) {\n          this.setContextStrokeState_(this.strokeState_);\n        }\n        var context = this.context_;\n        context.beginPath();\n        this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, /** @type {Array<number>} */geometry.getEnds(), geometry.getStride());\n        if (this.fillState_) {\n          context.fill();\n        }\n        if (this.strokeState_) {\n          context.stroke();\n        }\n      }\n      if (this.text_ !== '') {\n        var flatInteriorPoint = geometry.getFlatInteriorPoint();\n        this.drawText_(flatInteriorPoint, 0, 2, 2);\n      }\n    }\n    /**\n     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and\n     * uses the current style.\n     * @param {import(\"../../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n     */\n  }, {\n    key: \"drawMultiPolygon\",\n    value: function drawMultiPolygon(geometry) {\n      if (this.squaredTolerance_) {\n        geometry = /** @type {import(\"../../geom/MultiPolygon.js\").default} */\n        geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n      }\n      if (!intersects(this.extent_, geometry.getExtent())) {\n        return;\n      }\n      if (this.strokeState_ || this.fillState_) {\n        if (this.fillState_) {\n          this.setContextFillState_(this.fillState_);\n        }\n        if (this.strokeState_) {\n          this.setContextStrokeState_(this.strokeState_);\n        }\n        var context = this.context_;\n        var flatCoordinates = geometry.getOrientedFlatCoordinates();\n        var offset = 0;\n        var endss = geometry.getEndss();\n        var stride = geometry.getStride();\n        context.beginPath();\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n          var ends = endss[i];\n          offset = this.drawRings_(flatCoordinates, offset, ends, stride);\n        }\n        if (this.fillState_) {\n          context.fill();\n        }\n        if (this.strokeState_) {\n          context.stroke();\n        }\n      }\n      if (this.text_ !== '') {\n        var flatInteriorPoints = geometry.getFlatInteriorPoints();\n        this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);\n      }\n    }\n    /**\n     * @param {import(\"../canvas.js\").FillState} fillState Fill state.\n     * @private\n     */\n  }, {\n    key: \"setContextFillState_\",\n    value: function setContextFillState_(fillState) {\n      var context = this.context_;\n      var contextFillState = this.contextFillState_;\n      if (!contextFillState) {\n        context.fillStyle = fillState.fillStyle;\n        this.contextFillState_ = {\n          fillStyle: fillState.fillStyle\n        };\n      } else {\n        if (contextFillState.fillStyle != fillState.fillStyle) {\n          contextFillState.fillStyle = fillState.fillStyle;\n          context.fillStyle = fillState.fillStyle;\n        }\n      }\n    }\n    /**\n     * @param {import(\"../canvas.js\").StrokeState} strokeState Stroke state.\n     * @private\n     */\n  }, {\n    key: \"setContextStrokeState_\",\n    value: function setContextStrokeState_(strokeState) {\n      var context = this.context_;\n      var contextStrokeState = this.contextStrokeState_;\n      if (!contextStrokeState) {\n        context.lineCap = strokeState.lineCap;\n        context.setLineDash(strokeState.lineDash);\n        context.lineDashOffset = strokeState.lineDashOffset;\n        context.lineJoin = strokeState.lineJoin;\n        context.lineWidth = strokeState.lineWidth;\n        context.miterLimit = strokeState.miterLimit;\n        context.strokeStyle = strokeState.strokeStyle;\n        this.contextStrokeState_ = {\n          lineCap: strokeState.lineCap,\n          lineDash: strokeState.lineDash,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineJoin: strokeState.lineJoin,\n          lineWidth: strokeState.lineWidth,\n          miterLimit: strokeState.miterLimit,\n          strokeStyle: strokeState.strokeStyle\n        };\n      } else {\n        if (contextStrokeState.lineCap != strokeState.lineCap) {\n          contextStrokeState.lineCap = strokeState.lineCap;\n          context.lineCap = strokeState.lineCap;\n        }\n        if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {\n          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);\n        }\n        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {\n          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;\n          context.lineDashOffset = strokeState.lineDashOffset;\n        }\n        if (contextStrokeState.lineJoin != strokeState.lineJoin) {\n          contextStrokeState.lineJoin = strokeState.lineJoin;\n          context.lineJoin = strokeState.lineJoin;\n        }\n        if (contextStrokeState.lineWidth != strokeState.lineWidth) {\n          contextStrokeState.lineWidth = strokeState.lineWidth;\n          context.lineWidth = strokeState.lineWidth;\n        }\n        if (contextStrokeState.miterLimit != strokeState.miterLimit) {\n          contextStrokeState.miterLimit = strokeState.miterLimit;\n          context.miterLimit = strokeState.miterLimit;\n        }\n        if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {\n          contextStrokeState.strokeStyle = strokeState.strokeStyle;\n          context.strokeStyle = strokeState.strokeStyle;\n        }\n      }\n    }\n    /**\n     * @param {import(\"../canvas.js\").TextState} textState Text state.\n     * @private\n     */\n  }, {\n    key: \"setContextTextState_\",\n    value: function setContextTextState_(textState) {\n      var context = this.context_;\n      var contextTextState = this.contextTextState_;\n      var textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;\n      if (!contextTextState) {\n        context.font = textState.font;\n        context.textAlign = textAlign;\n        context.textBaseline = textState.textBaseline;\n        this.contextTextState_ = {\n          font: textState.font,\n          textAlign: textAlign,\n          textBaseline: textState.textBaseline\n        };\n      } else {\n        if (contextTextState.font != textState.font) {\n          contextTextState.font = textState.font;\n          context.font = textState.font;\n        }\n        if (contextTextState.textAlign != textAlign) {\n          contextTextState.textAlign = textAlign;\n          context.textAlign = textAlign;\n        }\n        if (contextTextState.textBaseline != textState.textBaseline) {\n          contextTextState.textBaseline = textState.textBaseline;\n          context.textBaseline = textState.textBaseline;\n        }\n      }\n    }\n    /**\n     * Set the fill and stroke style for subsequent draw operations.  To clear\n     * either fill or stroke styles, pass null for the appropriate parameter.\n     *\n     * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n     * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n     */\n  }, {\n    key: \"setFillStrokeStyle\",\n    value: function setFillStrokeStyle(fillStyle, strokeStyle) {\n      var _this2 = this;\n      if (!fillStyle) {\n        this.fillState_ = null;\n      } else {\n        var fillStyleColor = fillStyle.getColor();\n        this.fillState_ = {\n          fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)\n        };\n      }\n      if (!strokeStyle) {\n        this.strokeState_ = null;\n      } else {\n        var strokeStyleColor = strokeStyle.getColor();\n        var strokeStyleLineCap = strokeStyle.getLineCap();\n        var strokeStyleLineDash = strokeStyle.getLineDash();\n        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n        var strokeStyleLineJoin = strokeStyle.getLineJoin();\n        var strokeStyleWidth = strokeStyle.getWidth();\n        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n        var lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;\n        this.strokeState_ = {\n          lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap,\n          lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function (n) {\n            return n * _this2.pixelRatio_;\n          }),\n          lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,\n          lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin,\n          lineWidth: (strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,\n          miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit,\n          strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)\n        };\n      }\n    }\n    /**\n     * Set the image style for subsequent draw operations.  Pass null to remove\n     * the image style.\n     *\n     * @param {import(\"../../style/Image.js\").default} imageStyle Image style.\n     */\n  }, {\n    key: \"setImageStyle\",\n    value: function setImageStyle(imageStyle) {\n      var imageSize;\n      if (!imageStyle || !(imageSize = imageStyle.getSize())) {\n        this.image_ = null;\n        return;\n      }\n      var imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);\n      var imageAnchor = imageStyle.getAnchor();\n      var imageOrigin = imageStyle.getOrigin();\n      this.image_ = imageStyle.getImage(this.pixelRatio_);\n      this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;\n      this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;\n      this.imageHeight_ = imageSize[1] * imagePixelRatio;\n      this.imageOpacity_ = imageStyle.getOpacity();\n      this.imageOriginX_ = imageOrigin[0];\n      this.imageOriginY_ = imageOrigin[1];\n      this.imageRotateWithView_ = imageStyle.getRotateWithView();\n      this.imageRotation_ = imageStyle.getRotation();\n      var imageScale = imageStyle.getScaleArray();\n      this.imageScale_ = [imageScale[0] * this.pixelRatio_ / imagePixelRatio, imageScale[1] * this.pixelRatio_ / imagePixelRatio];\n      this.imageWidth_ = imageSize[0] * imagePixelRatio;\n    }\n    /**\n     * Set the text style for subsequent draw operations.  Pass null to\n     * remove the text style.\n     *\n     * @param {import(\"../../style/Text.js\").default} textStyle Text style.\n     */\n  }, {\n    key: \"setTextStyle\",\n    value: function setTextStyle(textStyle) {\n      if (!textStyle) {\n        this.text_ = '';\n      } else {\n        var textFillStyle = textStyle.getFill();\n        if (!textFillStyle) {\n          this.textFillState_ = null;\n        } else {\n          var textFillStyleColor = textFillStyle.getColor();\n          this.textFillState_ = {\n            fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)\n          };\n        }\n        var textStrokeStyle = textStyle.getStroke();\n        if (!textStrokeStyle) {\n          this.textStrokeState_ = null;\n        } else {\n          var textStrokeStyleColor = textStrokeStyle.getColor();\n          var textStrokeStyleLineCap = textStrokeStyle.getLineCap();\n          var textStrokeStyleLineDash = textStrokeStyle.getLineDash();\n          var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();\n          var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();\n          var textStrokeStyleWidth = textStrokeStyle.getWidth();\n          var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();\n          this.textStrokeState_ = {\n            lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : defaultLineCap,\n            lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,\n            lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,\n            lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : defaultLineJoin,\n            lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : defaultLineWidth,\n            miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : defaultMiterLimit,\n            strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)\n          };\n        }\n        var textFont = textStyle.getFont();\n        var textOffsetX = textStyle.getOffsetX();\n        var textOffsetY = textStyle.getOffsetY();\n        var textRotateWithView = textStyle.getRotateWithView();\n        var textRotation = textStyle.getRotation();\n        var textScale = textStyle.getScaleArray();\n        var textText = textStyle.getText();\n        var textTextAlign = textStyle.getTextAlign();\n        var textTextBaseline = textStyle.getTextBaseline();\n        this.textState_ = {\n          font: textFont !== undefined ? textFont : defaultFont,\n          textAlign: textTextAlign !== undefined ? textTextAlign : defaultTextAlign,\n          textBaseline: textTextBaseline !== undefined ? textTextBaseline : defaultTextBaseline\n        };\n        this.text_ = textText !== undefined ? Array.isArray(textText) ? textText.reduce(function (acc, t, i) {\n          return acc += i % 2 ? ' ' : t;\n        }, '') : textText : '';\n        this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;\n        this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;\n        this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;\n        this.textRotation_ = textRotation !== undefined ? textRotation : 0;\n        this.textScale_ = [this.pixelRatio_ * textScale[0], this.pixelRatio_ * textScale[1]];\n      }\n    }\n  }]);\n  return CanvasImmediateRenderer;\n}(VectorContext);\nexport default CanvasImmediateRenderer;","map":null,"metadata":{},"sourceType":"module"}
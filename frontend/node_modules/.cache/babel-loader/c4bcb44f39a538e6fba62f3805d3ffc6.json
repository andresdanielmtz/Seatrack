{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n/**\n * @module ol/MapBrowserEventHandler\n */\n\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { VOID } from './functions.js';\nimport { listen, unlistenByKey } from './events.js';\nvar MapBrowserEventHandler = /*#__PURE__*/function (_Target) {\n  _inherits(MapBrowserEventHandler, _Target);\n  /**\n   * @param {import(\"./Map.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n  function MapBrowserEventHandler(map, moveTolerance) {\n    var _this;\n    _classCallCheck(this, MapBrowserEventHandler);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapBrowserEventHandler).call(this, map));\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./Map.js\").default}\n     * @private\n     */\n    _this.map_ = map;\n\n    /**\n     * @type {any}\n     * @private\n     */\n    _this.clickTimeoutId_;\n\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n    _this.emulateClicks_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    _this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n    _this.down_ = null;\n    var element = _this.map_.getViewport();\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n    _this.activePointers_ = [];\n\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n    _this.trackedTouches_ = {};\n    _this.element_ = element;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _assertThisInitialized(_assertThisInitialized(_this)));\n\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    _this.originalPointerMoveEvent_;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayMoveEvent_, _assertThisInitialized(_assertThisInitialized(_this)));\n\n    /**\n     * @private\n     */\n    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n    return _this;\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  _createClass(MapBrowserEventHandler, [{\n    key: \"emulateClick_\",\n    value: function emulateClick_(pointerEvent) {\n      var _this2 = this;\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n      if (this.clickTimeoutId_ !== undefined) {\n        // double-click\n        clearTimeout(this.clickTimeoutId_);\n        this.clickTimeoutId_ = undefined;\n        newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      } else {\n        // click\n        this.clickTimeoutId_ = setTimeout(function () {\n          _this2.clickTimeoutId_ = undefined;\n          var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, _this2.map_, pointerEvent);\n          _this2.dispatchEvent(newEvent);\n        }, 250);\n      }\n    }\n    /**\n     * Keeps track on how many pointers are currently active.\n     *\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"updateActivePointers_\",\n    value: function updateActivePointers_(pointerEvent) {\n      var event = pointerEvent;\n      var id = event.pointerId;\n      if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n        delete this.trackedTouches_[id];\n        for (var pointerId in this.trackedTouches_) {\n          if (this.trackedTouches_[pointerId].target !== event.target) {\n            // Some platforms assign a new pointerId when the target changes.\n            // If this happens, delete one tracked pointer. If there is more\n            // than one tracked pointer for the old target, it will be cleared\n            // by subsequent POINTERUP events from other pointers.\n            delete this.trackedTouches_[pointerId];\n            break;\n          }\n        }\n      } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {\n        this.trackedTouches_[id] = event;\n      }\n      this.activePointers_ = Object.values(this.trackedTouches_);\n    }\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"handlePointerUp_\",\n    value: function handlePointerUp_(pointerEvent) {\n      this.updateActivePointers_(pointerEvent);\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n\n      // We emulate click events on left mouse button click, touch contact, and pen\n      // contact. isMouseActionButton returns true in these cases (evt.button is set\n      // to 0).\n      // See http://www.w3.org/TR/pointerevents/#button-states\n      // We only fire click, singleclick, and doubleclick if nobody has called\n      // event.preventDefault().\n      if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n        this.emulateClick_(this.down_);\n      }\n      if (this.activePointers_.length === 0) {\n        this.dragListenerKeys_.forEach(unlistenByKey);\n        this.dragListenerKeys_.length = 0;\n        this.dragging_ = false;\n        this.down_ = null;\n      }\n    }\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @return {boolean} If the left mouse button was pressed.\n     * @private\n     */\n  }, {\n    key: \"isMouseActionButton_\",\n    value: function isMouseActionButton_(pointerEvent) {\n      return pointerEvent.button === 0;\n    }\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"handlePointerDown_\",\n    value: function handlePointerDown_(pointerEvent) {\n      this.emulateClicks_ = this.activePointers_.length === 0;\n      this.updateActivePointers_(pointerEvent);\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n\n      // Store a copy of the down event\n      this.down_ = /** @type {PointerEvent} */{};\n      for (var property in pointerEvent) {\n        var value = pointerEvent[property];\n        this.down_[property] = typeof value === 'function' ? VOID : value;\n      }\n      if (this.dragListenerKeys_.length === 0) {\n        var doc = this.map_.getOwnerDocument();\n        this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n        /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n        listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n        if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n          this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n        }\n      }\n    }\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"handlePointerMove_\",\n    value: function handlePointerMove_(pointerEvent) {\n      // Between pointerdown and pointerup, pointermove events are triggered.\n      // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n      // moved a significant distance.\n      if (this.isMoving_(pointerEvent)) {\n        this.updateActivePointers_(pointerEvent);\n        this.dragging_ = true;\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n        this.dispatchEvent(newEvent);\n      }\n    }\n    /**\n     * Wrap and relay a pointermove event.\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @private\n     */\n  }, {\n    key: \"relayMoveEvent_\",\n    value: function relayMoveEvent_(pointerEvent) {\n      this.originalPointerMoveEvent_ = pointerEvent;\n      var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n      this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n    }\n    /**\n     * Flexible handling of a `touch-action: none` css equivalent: because calling\n     * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n     * when an interaction (currently `DragPan` handles the event.\n     * @param {TouchEvent} event Event.\n     * @private\n     */\n  }, {\n    key: \"handleTouchMove_\",\n    value: function handleTouchMove_(event) {\n      // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n      // may not be initialized yet when we get here on a platform without native pointer events.\n      var originalEvent = this.originalPointerMoveEvent_;\n      if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n        event.preventDefault();\n      }\n    }\n    /**\n     * @param {PointerEvent} pointerEvent Pointer\n     * event.\n     * @return {boolean} Is moving.\n     * @private\n     */\n  }, {\n    key: \"isMoving_\",\n    value: function isMoving_(pointerEvent) {\n      return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"disposeInternal\",\n    value: function disposeInternal() {\n      if (this.relayedListenerKey_) {\n        unlistenByKey(this.relayedListenerKey_);\n        this.relayedListenerKey_ = null;\n      }\n      this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n      if (this.pointerdownListenerKey_) {\n        unlistenByKey(this.pointerdownListenerKey_);\n        this.pointerdownListenerKey_ = null;\n      }\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.element_ = null;\n      _get(_getPrototypeOf(MapBrowserEventHandler.prototype), \"disposeInternal\", this).call(this);\n    }\n  }]);\n  return MapBrowserEventHandler;\n}(Target);\nexport default MapBrowserEventHandler;","map":null,"metadata":{},"sourceType":"module"}
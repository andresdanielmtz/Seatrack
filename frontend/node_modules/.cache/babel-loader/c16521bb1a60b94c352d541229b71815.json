{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n/**\n * @module ol/structs/PriorityQueue\n */\nimport { assert } from '../asserts.js';\nimport { clear as _clear } from '../obj.js';\n\n/**\n * @type {number}\n */\nexport var DROP = Infinity;\n\n/**\n * @classdesc\n * Priority queue.\n *\n * The implementation is inspired from the Closure Library's Heap class and\n * Python's heapq module.\n *\n * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js\n * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.\n *\n * @template T\n */\nvar PriorityQueue = /*#__PURE__*/function () {\n  /**\n   * @param {function(T): number} priorityFunction Priority function.\n   * @param {function(T): string} keyFunction Key function.\n   */\n  function PriorityQueue(priorityFunction, keyFunction) {\n    _classCallCheck(this, PriorityQueue);\n    /**\n     * @type {function(T): number}\n     * @private\n     */\n    this.priorityFunction_ = priorityFunction;\n\n    /**\n     * @type {function(T): string}\n     * @private\n     */\n    this.keyFunction_ = keyFunction;\n\n    /**\n     * @type {Array<T>}\n     * @private\n     */\n    this.elements_ = [];\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.priorities_ = [];\n\n    /**\n     * @type {!Object<string, boolean>}\n     * @private\n     */\n    this.queuedElements_ = {};\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  _createClass(PriorityQueue, [{\n    key: \"clear\",\n    value: function clear() {\n      this.elements_.length = 0;\n      this.priorities_.length = 0;\n      _clear(this.queuedElements_);\n    }\n    /**\n     * Remove and return the highest-priority element. O(log N).\n     * @return {T} Element.\n     */\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      var elements = this.elements_;\n      var priorities = this.priorities_;\n      var element = elements[0];\n      if (elements.length == 1) {\n        elements.length = 0;\n        priorities.length = 0;\n      } else {\n        elements[0] = elements.pop();\n        priorities[0] = priorities.pop();\n        this.siftUp_(0);\n      }\n      var elementKey = this.keyFunction_(element);\n      delete this.queuedElements_[elementKey];\n      return element;\n    }\n    /**\n     * Enqueue an element. O(log N).\n     * @param {T} element Element.\n     * @return {boolean} The element was added to the queue.\n     */\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(element) {\n      assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue\n      var priority = this.priorityFunction_(element);\n      if (priority != DROP) {\n        this.elements_.push(element);\n        this.priorities_.push(priority);\n        this.queuedElements_[this.keyFunction_(element)] = true;\n        this.siftDown_(0, this.elements_.length - 1);\n        return true;\n      }\n      return false;\n    }\n    /**\n     * @return {number} Count.\n     */\n  }, {\n    key: \"getCount\",\n    value: function getCount() {\n      return this.elements_.length;\n    }\n    /**\n     * Gets the index of the left child of the node at the given index.\n     * @param {number} index The index of the node to get the left child for.\n     * @return {number} The index of the left child.\n     * @private\n     */\n  }, {\n    key: \"getLeftChildIndex_\",\n    value: function getLeftChildIndex_(index) {\n      return index * 2 + 1;\n    }\n    /**\n     * Gets the index of the right child of the node at the given index.\n     * @param {number} index The index of the node to get the right child for.\n     * @return {number} The index of the right child.\n     * @private\n     */\n  }, {\n    key: \"getRightChildIndex_\",\n    value: function getRightChildIndex_(index) {\n      return index * 2 + 2;\n    }\n    /**\n     * Gets the index of the parent of the node at the given index.\n     * @param {number} index The index of the node to get the parent for.\n     * @return {number} The index of the parent.\n     * @private\n     */\n  }, {\n    key: \"getParentIndex_\",\n    value: function getParentIndex_(index) {\n      return index - 1 >> 1;\n    }\n    /**\n     * Make this a heap. O(N).\n     * @private\n     */\n  }, {\n    key: \"heapify_\",\n    value: function heapify_() {\n      var i;\n      for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n        this.siftUp_(i);\n      }\n    }\n    /**\n     * @return {boolean} Is empty.\n     */\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.elements_.length === 0;\n    }\n    /**\n     * @param {string} key Key.\n     * @return {boolean} Is key queued.\n     */\n  }, {\n    key: \"isKeyQueued\",\n    value: function isKeyQueued(key) {\n      return key in this.queuedElements_;\n    }\n    /**\n     * @param {T} element Element.\n     * @return {boolean} Is queued.\n     */\n  }, {\n    key: \"isQueued\",\n    value: function isQueued(element) {\n      return this.isKeyQueued(this.keyFunction_(element));\n    }\n    /**\n     * @param {number} index The index of the node to move down.\n     * @private\n     */\n  }, {\n    key: \"siftUp_\",\n    value: function siftUp_(index) {\n      var elements = this.elements_;\n      var priorities = this.priorities_;\n      var count = elements.length;\n      var element = elements[index];\n      var priority = priorities[index];\n      var startIndex = index;\n      while (index < count >> 1) {\n        var lIndex = this.getLeftChildIndex_(index);\n        var rIndex = this.getRightChildIndex_(index);\n        var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;\n        elements[index] = elements[smallerChildIndex];\n        priorities[index] = priorities[smallerChildIndex];\n        index = smallerChildIndex;\n      }\n      elements[index] = element;\n      priorities[index] = priority;\n      this.siftDown_(startIndex, index);\n    }\n    /**\n     * @param {number} startIndex The index of the root.\n     * @param {number} index The index of the node to move up.\n     * @private\n     */\n  }, {\n    key: \"siftDown_\",\n    value: function siftDown_(startIndex, index) {\n      var elements = this.elements_;\n      var priorities = this.priorities_;\n      var element = elements[index];\n      var priority = priorities[index];\n      while (index > startIndex) {\n        var parentIndex = this.getParentIndex_(index);\n        if (priorities[parentIndex] > priority) {\n          elements[index] = elements[parentIndex];\n          priorities[index] = priorities[parentIndex];\n          index = parentIndex;\n        } else {\n          break;\n        }\n      }\n      elements[index] = element;\n      priorities[index] = priority;\n    }\n    /**\n     * FIXME empty description for jsdoc\n     */\n  }, {\n    key: \"reprioritize\",\n    value: function reprioritize() {\n      var priorityFunction = this.priorityFunction_;\n      var elements = this.elements_;\n      var priorities = this.priorities_;\n      var index = 0;\n      var n = elements.length;\n      var element, i, priority;\n      for (i = 0; i < n; ++i) {\n        element = elements[i];\n        priority = priorityFunction(element);\n        if (priority == DROP) {\n          delete this.queuedElements_[this.keyFunction_(element)];\n        } else {\n          priorities[index] = priority;\n          elements[index++] = element;\n        }\n      }\n      elements.length = index;\n      priorities.length = index;\n      this.heapify_();\n    }\n  }]);\n  return PriorityQueue;\n}();\nexport default PriorityQueue;","map":null,"metadata":{},"sourceType":"module"}
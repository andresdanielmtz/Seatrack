{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n/**\n * @module ol/structs/LRUCache\n */\n\nimport { assert } from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Object} newer Newer.\n * @property {Object} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nvar LRUCache = /*#__PURE__*/function () {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  function LRUCache(highWaterMark) {\n    _classCallCheck(this, LRUCache);\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  _createClass(LRUCache, [{\n    key: \"canExpireCache\",\n    value: function canExpireCache() {\n      return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n    }\n    /**\n     * Expire the cache.\n     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n     */\n  }, {\n    key: \"expireCache\",\n    value: function expireCache(keep) {\n      while (this.canExpireCache()) {\n        this.pop();\n      }\n    }\n    /**\n     * FIXME empty description for jsdoc\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.count_ = 0;\n      this.entries_ = {};\n      this.oldest_ = null;\n      this.newest_ = null;\n    }\n    /**\n     * @param {string} key Key.\n     * @return {boolean} Contains key.\n     */\n  }, {\n    key: \"containsKey\",\n    value: function containsKey(key) {\n      return this.entries_.hasOwnProperty(key);\n    }\n    /**\n     * @param {function(T, string, LRUCache<T>): ?} f The function\n     *     to call for every entry from the oldest to the newer. This function takes\n     *     3 arguments (the entry value, the entry key and the LRUCache object).\n     *     The return value is ignored.\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      var entry = this.oldest_;\n      while (entry) {\n        f(entry.value_, entry.key_, this);\n        entry = entry.newer;\n      }\n    }\n    /**\n     * @param {string} key Key.\n     * @param {*} [options] Options (reserved for subclasses).\n     * @return {T} Value.\n     */\n  }, {\n    key: \"get\",\n    value: function get(key, options) {\n      var entry = this.entries_[key];\n      assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n      if (entry === this.newest_) {\n        return entry.value_;\n      } else if (entry === this.oldest_) {\n        this.oldest_ = /** @type {Entry} */this.oldest_.newer;\n        this.oldest_.older = null;\n      } else {\n        entry.newer.older = entry.older;\n        entry.older.newer = entry.newer;\n      }\n      entry.newer = null;\n      entry.older = this.newest_;\n      this.newest_.newer = entry;\n      this.newest_ = entry;\n      return entry.value_;\n    }\n    /**\n     * Remove an entry from the cache.\n     * @param {string} key The entry key.\n     * @return {T} The removed entry.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var entry = this.entries_[key];\n      assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n      if (entry === this.newest_) {\n        this.newest_ = /** @type {Entry} */entry.older;\n        if (this.newest_) {\n          this.newest_.newer = null;\n        }\n      } else if (entry === this.oldest_) {\n        this.oldest_ = /** @type {Entry} */entry.newer;\n        if (this.oldest_) {\n          this.oldest_.older = null;\n        }\n      } else {\n        entry.newer.older = entry.older;\n        entry.older.newer = entry.newer;\n      }\n      delete this.entries_[key];\n      --this.count_;\n      return entry.value_;\n    }\n    /**\n     * @return {number} Count.\n     */\n  }, {\n    key: \"getCount\",\n    value: function getCount() {\n      return this.count_;\n    }\n    /**\n     * @return {Array<string>} Keys.\n     */\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      var keys = new Array(this.count_);\n      var i = 0;\n      var entry;\n      for (entry = this.newest_; entry; entry = entry.older) {\n        keys[i++] = entry.key_;\n      }\n      return keys;\n    }\n    /**\n     * @return {Array<T>} Values.\n     */\n  }, {\n    key: \"getValues\",\n    value: function getValues() {\n      var values = new Array(this.count_);\n      var i = 0;\n      var entry;\n      for (entry = this.newest_; entry; entry = entry.older) {\n        values[i++] = entry.value_;\n      }\n      return values;\n    }\n    /**\n     * @return {T} Last value.\n     */\n  }, {\n    key: \"peekLast\",\n    value: function peekLast() {\n      return this.oldest_.value_;\n    }\n    /**\n     * @return {string} Last key.\n     */\n  }, {\n    key: \"peekLastKey\",\n    value: function peekLastKey() {\n      return this.oldest_.key_;\n    }\n    /**\n     * Get the key of the newest item in the cache.  Throws if the cache is empty.\n     * @return {string} The newest key.\n     */\n  }, {\n    key: \"peekFirstKey\",\n    value: function peekFirstKey() {\n      return this.newest_.key_;\n    }\n    /**\n     * Return an entry without updating least recently used time.\n     * @param {string} key Key.\n     * @return {T} Value.\n     */\n  }, {\n    key: \"peek\",\n    value: function peek(key) {\n      if (!this.containsKey(key)) {\n        return undefined;\n      }\n      return this.entries_[key].value_;\n    }\n    /**\n     * @return {T} value Value.\n     */\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      var entry = this.oldest_;\n      delete this.entries_[entry.key_];\n      if (entry.newer) {\n        entry.newer.older = null;\n      }\n      this.oldest_ = /** @type {Entry} */entry.newer;\n      if (!this.oldest_) {\n        this.newest_ = null;\n      }\n      --this.count_;\n      return entry.value_;\n    }\n    /**\n     * @param {string} key Key.\n     * @param {T} value Value.\n     */\n  }, {\n    key: \"replace\",\n    value: function replace(key, value) {\n      this.get(key); // update `newest_`\n      this.entries_[key].value_ = value;\n    }\n    /**\n     * @param {string} key Key.\n     * @param {T} value Value.\n     */\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n      var entry = {\n        key_: key,\n        newer: null,\n        older: this.newest_,\n        value_: value\n      };\n      if (!this.newest_) {\n        this.oldest_ = entry;\n      } else {\n        this.newest_.newer = entry;\n      }\n      this.newest_ = entry;\n      this.entries_[key] = entry;\n      ++this.count_;\n    }\n    /**\n     * Set a maximum number of entries for the cache.\n     * @param {number} size Cache size.\n     * @api\n     */\n  }, {\n    key: \"setSize\",\n    value: function setSize(size) {\n      this.highWaterMark = size;\n    }\n  }]);\n  return LRUCache;\n}();\nexport default LRUCache;","map":null,"metadata":{},"sourceType":"module"}
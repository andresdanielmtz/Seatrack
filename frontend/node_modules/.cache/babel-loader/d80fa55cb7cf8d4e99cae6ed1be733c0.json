{"ast":null,"code":"import _toConsumableArray from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n/**\n * @module ol/render/canvas/ExecutorGroup\n */\n\nimport Executor from './Executor.js';\nimport { ascending } from '../../array.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty as _isEmpty } from '../../obj.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n\n/**\n * @const\n * @type {Array<import(\"../canvas.js\").BuilderType>}\n */\nvar ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];\nvar ExecutorGroup = /*#__PURE__*/function () {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceed that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number} [renderBuffer] Optional rendering buffer.\n   */\n  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {\n    _classCallCheck(this, ExecutorGroup);\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"./Executor\").default>>}\n     */\n    this.executorsByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n    this.createExecutors_(allInstructions);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  _createClass(ExecutorGroup, [{\n    key: \"clip\",\n    value: function clip(context, transform) {\n      var flatClipCoords = this.getClipCoords(transform);\n      context.beginPath();\n      context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n      context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n      context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n      context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n      context.clip();\n    }\n    /**\n     * Create executors and populate them using the provided instructions.\n     * @private\n     * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\n     */\n  }, {\n    key: \"createExecutors_\",\n    value: function createExecutors_(allInstructions) {\n      for (var zIndex in allInstructions) {\n        var executors = this.executorsByZIndex_[zIndex];\n        if (executors === undefined) {\n          executors = {};\n          this.executorsByZIndex_[zIndex] = executors;\n        }\n        var instructionByZindex = allInstructions[zIndex];\n        for (var builderType in instructionByZindex) {\n          var instructions = instructionByZindex[builderType];\n          executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);\n        }\n      }\n    }\n    /**\n     * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\n     * @return {boolean} Has executors of the provided types.\n     */\n  }, {\n    key: \"hasExecutors\",\n    value: function hasExecutors(executors) {\n      for (var zIndex in this.executorsByZIndex_) {\n        var candidates = this.executorsByZIndex_[zIndex];\n        for (var i = 0, ii = executors.length; i < ii; ++i) {\n          if (executors[i] in candidates) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {number} rotation Rotation.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\n     * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n  }, {\n    key: \"forEachFeatureAtCoordinate\",\n    value: function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n      hitTolerance = Math.round(hitTolerance);\n      var contextSize = hitTolerance * 2 + 1;\n      var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n      var newContext = !this.hitDetectionContext_;\n      if (newContext) {\n        this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize, undefined, {\n          willReadFrequently: true\n        });\n      }\n      var context = this.hitDetectionContext_;\n      if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n        context.canvas.width = contextSize;\n        context.canvas.height = contextSize;\n      } else if (!newContext) {\n        context.clearRect(0, 0, contextSize, contextSize);\n      }\n\n      /**\n       * @type {import(\"../../extent.js\").Extent}\n       */\n      var hitExtent;\n      if (this.renderBuffer_ !== undefined) {\n        hitExtent = createEmpty();\n        extendCoordinate(hitExtent, coordinate);\n        buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n      }\n      var indexes = getPixelIndexArray(hitTolerance);\n      var builderType;\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n       * @return {T|undefined} Callback result.\n       */\n      function featureCallback(feature, geometry) {\n        var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n        for (var _i = 0, ii = indexes.length; _i < ii; _i++) {\n          if (imageData[indexes[_i]] > 0) {\n            if (!declutteredFeatures || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.includes(feature)) {\n              var idx = (indexes[_i] - 3) / 4;\n              var x = hitTolerance - idx % contextSize;\n              var y = hitTolerance - (idx / contextSize | 0);\n              var _result = callback(feature, geometry, x * x + y * y);\n              if (_result) {\n                return _result;\n              }\n            }\n            context.clearRect(0, 0, contextSize, contextSize);\n            break;\n          }\n        }\n        return undefined;\n      }\n\n      /** @type {Array<number>} */\n      var zs = Object.keys(this.executorsByZIndex_).map(Number);\n      zs.sort(ascending);\n      var i, j, executors, executor, result;\n      for (i = zs.length - 1; i >= 0; --i) {\n        var zIndexKey = zs[i].toString();\n        executors = this.executorsByZIndex_[zIndexKey];\n        for (j = ORDER.length - 1; j >= 0; --j) {\n          builderType = ORDER[j];\n          executor = executors[builderType];\n          if (executor !== undefined) {\n            result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n      return undefined;\n    }\n    /**\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @return {Array<number>|null} Clip coordinates.\n     */\n  }, {\n    key: \"getClipCoords\",\n    value: function getClipCoords(transform) {\n      var maxExtent = this.maxExtent_;\n      if (!maxExtent) {\n        return null;\n      }\n      var minX = maxExtent[0];\n      var minY = maxExtent[1];\n      var maxX = maxExtent[2];\n      var maxY = maxExtent[3];\n      var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n      transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n      return flatClipCoords;\n    }\n    /**\n     * @return {boolean} Is empty.\n     */\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return _isEmpty(this.executorsByZIndex_);\n    }\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n     * @param {Array<import(\"../canvas.js\").BuilderType>} [builderTypes] Ordered replay types to replay.\n     *     Default is {@link module:ol/render/replay~ORDER}\n     * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n     */\n  }, {\n    key: \"execute\",\n    value: function execute(context, contextScale, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {\n      /** @type {Array<number>} */\n      var zs = Object.keys(this.executorsByZIndex_).map(Number);\n      zs.sort(ascending);\n\n      // setup clipping so that the parts of over-simplified geometries are not\n      // visible outside the current extent when panning\n      if (this.maxExtent_) {\n        context.save();\n        this.clip(context, transform);\n      }\n      builderTypes = builderTypes ? builderTypes : ORDER;\n      var i, ii, j, jj, replays, replay;\n      if (declutterTree) {\n        zs.reverse();\n      }\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        var zIndexKey = zs[i].toString();\n        replays = this.executorsByZIndex_[zIndexKey];\n        for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n          var builderType = builderTypes[j];\n          replay = replays[builderType];\n          if (replay !== undefined) {\n            replay.execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree);\n          }\n        }\n      }\n      if (this.maxExtent_) {\n        context.restore();\n      }\n    }\n  }]);\n  return ExecutorGroup;\n}();\n/**\n * This cache is used to store arrays of indexes for calculated pixel circles\n * to increase performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<number>>}\n */\nvar circlePixelIndexArrayCache = {};\n\n/**\n * This methods creates an array with indexes of all pixels within a circle,\n * ordered by how close they are to the center.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @return {Array<number>} An array with indexes within a circle.\n */\nexport function getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\n    return circlePixelIndexArrayCache[radius];\n  }\n  var size = radius * 2 + 1;\n  var maxDistanceSq = radius * radius;\n  var distances = new Array(maxDistanceSq + 1);\n  for (var i = 0; i <= radius; ++i) {\n    for (var j = 0; j <= radius; ++j) {\n      var distanceSq = i * i + j * j;\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n      var distance = distances[distanceSq];\n      if (!distance) {\n        distance = [];\n        distances[distanceSq] = distance;\n      }\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n      if (i > 0) {\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n      }\n      if (j > 0) {\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n        if (i > 0) {\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n        }\n      }\n    }\n  }\n  var pixelIndex = [];\n  for (var _i2 = 0, ii = distances.length; _i2 < ii; ++_i2) {\n    if (distances[_i2]) {\n      pixelIndex.push.apply(pixelIndex, _toConsumableArray(distances[_i2]));\n    }\n  }\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\nexport default ExecutorGroup;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/Overlay\n */\nimport BaseObject from './Object.js';\nimport MapEventType from './MapEventType.js';\nimport { CLASS_SELECTABLE } from './css.js';\nimport { containsExtent } from './extent.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { outerHeight, outerWidth, removeChildren, removeNode } from './dom.js';\n\n/**\n * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning\n * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, or `'top-right'`.\n */\n\n/**\n * @typedef {Object} Options\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\n * with the {@link module:ol/Map~Map#getOverlayById} method.\n * @property {HTMLElement} [element] The overlay element.\n * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n * the overlay. The first element in the\n * array is the horizontal offset. A positive value shifts the overlay right.\n * The second element in the array is the vertical offset. A positive value\n * shifts the overlay down.\n * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n * in map projection.\n * @property {Positioning} [positioning='top-left'] Defines how\n * the overlay is actually positioned with respect to its `position` property.\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, and `'top-right'`.\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\n * viewport should be stopped. If `true` the overlay is placed in the same\n * container as that of the controls (CSS class name\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n * with CSS class name specified by the `className` property.\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n * in the overlay container, or appended. If the overlay is placed in the same\n * container as that of the controls (see the `stopEvent` option) you will\n * probably set `insertFirst` to `true` so the overlay is displayed below the\n * controls.\n * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling\n * `setPosition`, so that the overlay is entirely visible in the current viewport.\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n * name.\n */\n\n/**\n * @typedef {Object} PanOptions\n * @property {number} [duration=1000] The duration of the animation in\n * milliseconds.\n * @property {function(number):number} [easing] The easing function to use. Can\n * be one from {@link module:ol/easing} or a custom function.\n * Default is {@link module:ol/easing.inAndOut}.\n */\n\n/**\n * @typedef {Object} PanIntoViewOptions\n * @property {PanOptions} [animation={}] The animation parameters for the pan\n * @property {number} [margin=20] The margin (in pixels) between the\n * overlay and the borders of the map when panning into view.\n */\n\n/**\n * @enum {string}\n * @protected\n */\nvar Property = {\n  ELEMENT: 'element',\n  MAP: 'map',\n  OFFSET: 'offset',\n  POSITION: 'position',\n  POSITIONING: 'positioning'\n};\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:element'|'change:map'|'change:offset'|'change:position'|\n *   'change:positioning'} OverlayObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<OverlayObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature\n */\n\n/**\n * @classdesc\n * An element to be displayed over the map and attached to a single map\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n * visible widgets. Unlike Controls, they are not in a fixed position on the\n * screen, but are tied to a geographical coordinate, so panning the map will\n * move an Overlay but not a Control.\n *\n * Example:\n *\n *     import Overlay from 'ol/Overlay.js';\n *\n *     // ...\n *     const popup = new Overlay({\n *       element: document.getElementById('popup'),\n *     });\n *     popup.setPosition(coordinate);\n *     map.addOverlay(popup);\n *\n * @api\n */\nvar Overlay = /*#__PURE__*/function (_BaseObject) {\n  _inherits(Overlay, _BaseObject);\n  /**\n   * @param {Options} options Overlay options.\n   */\n  function Overlay(options) {\n    var _this;\n    _classCallCheck(this, Overlay);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Overlay).call(this));\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    _this.on;\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    _this.once;\n\n    /***\n     * @type {OverlayOnSignature<void>}\n     */\n    _this.un;\n\n    /**\n     * @protected\n     * @type {Options}\n     */\n    _this.options = options;\n\n    /**\n     * @protected\n     * @type {number|string|undefined}\n     */\n    _this.id = options.id;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    _this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    _this.element = document.createElement('div');\n    _this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + CLASS_SELECTABLE;\n    _this.element.style.position = 'absolute';\n    _this.element.style.pointerEvents = 'auto';\n\n    /**\n     * @protected\n     * @type {PanIntoViewOptions|undefined}\n     */\n    _this.autoPan = options.autoPan === true ? {} : options.autoPan || undefined;\n\n    /**\n     * @protected\n     * @type {{transform_: string,\n     *         visible: boolean}}\n     */\n    _this.rendered = {\n      transform_: '',\n      visible: true\n    };\n\n    /**\n     * @protected\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    _this.mapPostrenderListenerKey = null;\n    _this.addChangeListener(Property.ELEMENT, _this.handleElementChanged);\n    _this.addChangeListener(Property.MAP, _this.handleMapChanged);\n    _this.addChangeListener(Property.OFFSET, _this.handleOffsetChanged);\n    _this.addChangeListener(Property.POSITION, _this.handlePositionChanged);\n    _this.addChangeListener(Property.POSITIONING, _this.handlePositioningChanged);\n    if (options.element !== undefined) {\n      _this.setElement(options.element);\n    }\n    _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n    _this.setPositioning(options.positioning || 'top-left');\n    if (options.position !== undefined) {\n      _this.setPosition(options.position);\n    }\n    return _this;\n  }\n\n  /**\n   * Get the DOM element of this overlay.\n   * @return {HTMLElement|undefined} The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  _createClass(Overlay, [{\n    key: \"getElement\",\n    value: function getElement() {\n      return (/** @type {HTMLElement|undefined} */this.get(Property.ELEMENT)\n      );\n    }\n    /**\n     * Get the overlay identifier which is set on constructor.\n     * @return {number|string|undefined} Id.\n     * @api\n     */\n  }, {\n    key: \"getId\",\n    value: function getId() {\n      return this.id;\n    }\n    /**\n     * Get the map associated with this overlay.\n     * @return {import(\"./Map.js\").default|null} The map that the\n     * overlay is part of.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return (/** @type {import(\"./Map.js\").default|null} */\n        this.get(Property.MAP) || null\n      );\n    }\n    /**\n     * Get the offset of this overlay.\n     * @return {Array<number>} The offset.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"getOffset\",\n    value: function getOffset() {\n      return (/** @type {Array<number>} */this.get(Property.OFFSET)\n      );\n    }\n    /**\n     * Get the current position of this overlay.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n     *     anchored at.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      return (/** @type {import(\"./coordinate.js\").Coordinate|undefined} */\n        this.get(Property.POSITION)\n      );\n    }\n    /**\n     * Get the current positioning of this overlay.\n     * @return {Positioning} How the overlay is positioned\n     *     relative to its point on the map.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"getPositioning\",\n    value: function getPositioning() {\n      return (/** @type {Positioning} */this.get(Property.POSITIONING)\n      );\n    }\n    /**\n     * @protected\n     */\n  }, {\n    key: \"handleElementChanged\",\n    value: function handleElementChanged() {\n      removeChildren(this.element);\n      var element = this.getElement();\n      if (element) {\n        this.element.appendChild(element);\n      }\n    }\n    /**\n     * @protected\n     */\n  }, {\n    key: \"handleMapChanged\",\n    value: function handleMapChanged() {\n      if (this.mapPostrenderListenerKey) {\n        removeNode(this.element);\n        unlistenByKey(this.mapPostrenderListenerKey);\n        this.mapPostrenderListenerKey = null;\n      }\n      var map = this.getMap();\n      if (map) {\n        this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);\n        this.updatePixelPosition();\n        var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();\n        if (this.insertFirst) {\n          container.insertBefore(this.element, container.childNodes[0] || null);\n        } else {\n          container.appendChild(this.element);\n        }\n        this.performAutoPan();\n      }\n    }\n    /**\n     * @protected\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.updatePixelPosition();\n    }\n    /**\n     * @protected\n     */\n  }, {\n    key: \"handleOffsetChanged\",\n    value: function handleOffsetChanged() {\n      this.updatePixelPosition();\n    }\n    /**\n     * @protected\n     */\n  }, {\n    key: \"handlePositionChanged\",\n    value: function handlePositionChanged() {\n      this.updatePixelPosition();\n      this.performAutoPan();\n    }\n    /**\n     * @protected\n     */\n  }, {\n    key: \"handlePositioningChanged\",\n    value: function handlePositioningChanged() {\n      this.updatePixelPosition();\n    }\n    /**\n     * Set the DOM element to be associated with this overlay.\n     * @param {HTMLElement|undefined} element The Element containing the overlay.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setElement\",\n    value: function setElement(element) {\n      this.set(Property.ELEMENT, element);\n    }\n    /**\n     * Set the map to be associated with this overlay.\n     * @param {import(\"./Map.js\").default|null} map The map that the\n     * overlay is part of. Pass `null` to just remove the overlay from the current map.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setMap\",\n    value: function setMap(map) {\n      this.set(Property.MAP, map);\n    }\n    /**\n     * Set the offset for this overlay.\n     * @param {Array<number>} offset Offset.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(offset) {\n      this.set(Property.OFFSET, offset);\n    }\n    /**\n     * Set the position for this overlay. If the position is `undefined` the\n     * overlay is hidden.\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n     *     is anchored at.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(position) {\n      this.set(Property.POSITION, position);\n    }\n    /**\n     * Pan the map so that the overlay is entirely visible in the current viewport\n     * (if necessary) using the configured autoPan parameters\n     * @protected\n     */\n  }, {\n    key: \"performAutoPan\",\n    value: function performAutoPan() {\n      if (this.autoPan) {\n        this.panIntoView(this.autoPan);\n      }\n    }\n    /**\n     * Pan the map so that the overlay is entirely visible in the current viewport\n     * (if necessary).\n     * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action\n     * @api\n     */\n  }, {\n    key: \"panIntoView\",\n    value: function panIntoView(panIntoViewOptions) {\n      var map = this.getMap();\n      if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {\n        return;\n      }\n      var mapRect = this.getRect(map.getTargetElement(), map.getSize());\n      var element = this.getElement();\n      var overlayRect = this.getRect(element, [outerWidth(element), outerHeight(element)]);\n      panIntoViewOptions = panIntoViewOptions || {};\n      var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;\n      if (!containsExtent(mapRect, overlayRect)) {\n        // the overlay is not completely inside the viewport, so pan the map\n        var offsetLeft = overlayRect[0] - mapRect[0];\n        var offsetRight = mapRect[2] - overlayRect[2];\n        var offsetTop = overlayRect[1] - mapRect[1];\n        var offsetBottom = mapRect[3] - overlayRect[3];\n        var delta = [0, 0];\n        if (offsetLeft < 0) {\n          // move map to the left\n          delta[0] = offsetLeft - myMargin;\n        } else if (offsetRight < 0) {\n          // move map to the right\n          delta[0] = Math.abs(offsetRight) + myMargin;\n        }\n        if (offsetTop < 0) {\n          // move map up\n          delta[1] = offsetTop - myMargin;\n        } else if (offsetBottom < 0) {\n          // move map down\n          delta[1] = Math.abs(offsetBottom) + myMargin;\n        }\n        if (delta[0] !== 0 || delta[1] !== 0) {\n          var center = /** @type {import(\"./coordinate.js\").Coordinate} */\n          map.getView().getCenterInternal();\n          var centerPx = map.getPixelFromCoordinateInternal(center);\n          if (!centerPx) {\n            return;\n          }\n          var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n          var panOptions = panIntoViewOptions.animation || {};\n          map.getView().animateInternal({\n            center: map.getCoordinateFromPixelInternal(newCenterPx),\n            duration: panOptions.duration,\n            easing: panOptions.easing\n          });\n        }\n      }\n    }\n    /**\n     * Get the extent of an element relative to the document\n     * @param {HTMLElement} element The element.\n     * @param {import(\"./size.js\").Size} size The size of the element.\n     * @return {import(\"./extent.js\").Extent} The extent.\n     * @protected\n     */\n  }, {\n    key: \"getRect\",\n    value: function getRect(element, size) {\n      var box = element.getBoundingClientRect();\n      var offsetX = box.left + window.pageXOffset;\n      var offsetY = box.top + window.pageYOffset;\n      return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n    }\n    /**\n     * Set the positioning for this overlay.\n     * @param {Positioning} positioning how the overlay is\n     *     positioned relative to its point on the map.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setPositioning\",\n    value: function setPositioning(positioning) {\n      this.set(Property.POSITIONING, positioning);\n    }\n    /**\n     * Modify the visibility of the element.\n     * @param {boolean} visible Element visibility.\n     * @protected\n     */\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      if (this.rendered.visible !== visible) {\n        this.element.style.display = visible ? '' : 'none';\n        this.rendered.visible = visible;\n      }\n    }\n    /**\n     * Update pixel position.\n     * @protected\n     */\n  }, {\n    key: \"updatePixelPosition\",\n    value: function updatePixelPosition() {\n      var map = this.getMap();\n      var position = this.getPosition();\n      if (!map || !map.isRendered() || !position) {\n        this.setVisible(false);\n        return;\n      }\n      var pixel = map.getPixelFromCoordinate(position);\n      var mapSize = map.getSize();\n      this.updateRenderedPosition(pixel, mapSize);\n    }\n    /**\n     * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n     * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n     * @protected\n     */\n  }, {\n    key: \"updateRenderedPosition\",\n    value: function updateRenderedPosition(pixel, mapSize) {\n      var style = this.element.style;\n      var offset = this.getOffset();\n      var positioning = this.getPositioning();\n      this.setVisible(true);\n      var x = Math.round(pixel[0] + offset[0]) + 'px';\n      var y = Math.round(pixel[1] + offset[1]) + 'px';\n      var posX = '0%';\n      var posY = '0%';\n      if (positioning == 'bottom-right' || positioning == 'center-right' || positioning == 'top-right') {\n        posX = '-100%';\n      } else if (positioning == 'bottom-center' || positioning == 'center-center' || positioning == 'top-center') {\n        posX = '-50%';\n      }\n      if (positioning == 'bottom-left' || positioning == 'bottom-center' || positioning == 'bottom-right') {\n        posY = '-100%';\n      } else if (positioning == 'center-left' || positioning == 'center-center' || positioning == 'center-right') {\n        posY = '-50%';\n      }\n      var transform = \"translate(\".concat(posX, \", \").concat(posY, \") translate(\").concat(x, \", \").concat(y, \")\");\n      if (this.rendered.transform_ != transform) {\n        this.rendered.transform_ = transform;\n        style.transform = transform;\n      }\n    }\n    /**\n     * returns the options this Overlay has been created with\n     * @return {Options} overlay options\n     */\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return this.options;\n    }\n  }]);\n  return Overlay;\n}(BaseObject);\nexport default Overlay;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { modulo } from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = /*#__PURE__*/function () {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {\n    var _this = this;\n    _classCallCheck(this, Triangulation);\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    var transformInvCache = {};\n    var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      var key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    var destinationTopLeft = getTopLeft(targetExtent);\n    var destinationTopRight = getTopRight(targetExtent);\n    var destinationBottomRight = getBottomRight(targetExtent);\n    var destinationBottomLeft = getBottomLeft(targetExtent);\n    var sourceTopLeft = this.transformInv_(destinationTopLeft);\n    var sourceTopRight = this.transformInv_(destinationTopRight);\n    var sourceBottomRight = this.transformInv_(destinationBottomRight);\n    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    var maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2(getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n    if (this.wrapsXInSource_) {\n      var leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(function (triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > _this.sourceWorldWidth_ / 2) {\n          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n          if (newTriangle[0][0] - leftBound > _this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= _this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > _this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= _this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > _this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= _this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          if (maxX - minX < _this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  _createClass(Triangulation, [{\n    key: \"addTriangle_\",\n    value: function addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n      this.triangles_.push({\n        source: [aSrc, bSrc, cSrc],\n        target: [a, b, c]\n      });\n    }\n    /**\n     * Adds quad (points in clock-wise order) to the triangulation\n     * (and reprojects the vertices) if valid.\n     * Performs quad subdivision if needed to increase precision.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n     * @private\n     */\n  }, {\n    key: \"addQuad_\",\n    value: function addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n      var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n      var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n      var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;\n\n      // when the quad is wrapped in the source projection\n      // it covers most of the projection extent, but not fully\n      var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n      var needsSubdivision = false;\n      if (maxSubdivision > 0) {\n        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n          var targetQuadExtent = boundingExtent([a, b, c, d]);\n          var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n          needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n        }\n        if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n          needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n        }\n      }\n      if (!needsSubdivision && this.maxSourceExtent_) {\n        if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n          if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n            // whole quad outside source projection extent -> ignore\n            return;\n          }\n        }\n      }\n      var isNotFinite = 0;\n      if (!needsSubdivision) {\n        if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n          if (maxSubdivision > 0) {\n            needsSubdivision = true;\n          } else {\n            // It might be the case that only 1 of the points is infinite. In this case\n            // we can draw a single triangle with the other three points\n            isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n            if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n              return;\n            }\n          }\n        }\n      }\n      if (maxSubdivision > 0) {\n        if (!needsSubdivision) {\n          var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n          var centerSrc = this.transformInv_(center);\n          var dx;\n          if (wrapsX) {\n            var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n            dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n          } else {\n            dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n          }\n          var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n          var centerSrcErrorSquared = dx * dx + dy * dy;\n          needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n        }\n        if (needsSubdivision) {\n          if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n            // split horizontally (top & bottom)\n            var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n            var bcSrc = this.transformInv_(bc);\n            var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n            var daSrc = this.transformInv_(da);\n            this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n            this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n          } else {\n            // split vertically (left & right)\n            var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n            var abSrc = this.transformInv_(ab);\n            var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n            var cdSrc = this.transformInv_(cd);\n            this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n            this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n          }\n          return;\n        }\n      }\n      if (wrapsX) {\n        if (!this.canWrapXInSource_) {\n          return;\n        }\n        this.wrapsXInSource_ = true;\n      }\n\n      // Exactly zero or one of *Src is not finite\n      // The triangles must have the diagonal line as the first side\n      // This is to allow easy code in reproj.s to make it straight for broken\n      // browsers that can't handle diagonal clipping\n      if ((isNotFinite & 0xb) == 0) {\n        this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n      }\n      if ((isNotFinite & 0xe) == 0) {\n        this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n      }\n      if (isNotFinite) {\n        // Try the other two triangles\n        if ((isNotFinite & 0xd) == 0) {\n          this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n        }\n        if ((isNotFinite & 0x7) == 0) {\n          this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n        }\n      }\n    }\n    /**\n     * Calculates extent of the `source` coordinates from all the triangles.\n     *\n     * @return {import(\"../extent.js\").Extent} Calculated extent.\n     */\n  }, {\n    key: \"calculateSourceExtent\",\n    value: function calculateSourceExtent() {\n      var extent = createEmpty();\n      this.triangles_.forEach(function (triangle, i, arr) {\n        var src = triangle.source;\n        extendCoordinate(extent, src[0]);\n        extendCoordinate(extent, src[1]);\n        extendCoordinate(extent, src[2]);\n      });\n      return extent;\n    }\n    /**\n     * @return {Array<Triangle>} Array of the calculated triangles.\n     */\n  }, {\n    key: \"getTriangles\",\n    value: function getTriangles() {\n      return this.triangles_;\n    }\n  }]);\n  return Triangulation;\n}();\nexport default Triangulation;","map":null,"metadata":{},"sourceType":"module"}
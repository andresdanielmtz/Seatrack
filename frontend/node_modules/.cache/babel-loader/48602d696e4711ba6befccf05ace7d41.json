{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport { TRUE } from '../functions.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, makeInverse } from '../transform.js';\nimport { getWidth } from '../extent.js';\nimport { shared as iconImageCache } from '../style/IconImageCache.js';\nimport { inView } from '../layer/Layer.js';\nimport { wrapX } from '../coordinate.js';\n\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n\n/**\n * @abstract\n */\nvar MapRenderer = /*#__PURE__*/function (_Disposable) {\n  _inherits(MapRenderer, _Disposable);\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  function MapRenderer(map) {\n    var _this;\n    _classCallCheck(this, MapRenderer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapRenderer).call(this));\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default}\n     */\n    _this.map_ = map;\n    return _this;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  _createClass(MapRenderer, [{\n    key: \"dispatchRenderEvent\",\n    value: function dispatchRenderEvent(type, frameState) {\n      abstract();\n    }\n    /**\n     * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n     * @protected\n     */\n  }, {\n    key: \"calculateMatrices2D\",\n    value: function calculateMatrices2D(frameState) {\n      var viewState = frameState.viewState;\n      var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n      var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n      composeTransform(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n      makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n    }\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {boolean} checkWrapped Check for wrapped geometries.\n     * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {S} thisArg Value to use as `this` when executing `callback`.\n     * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n     *     function, only layers which are visible and for which this function\n     *     returns `true` will be tested for features.  By default, all visible\n     *     layers will be tested.\n     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n     * @return {T|undefined} Callback result.\n     * @template S,T,U\n     */\n  }, {\n    key: \"forEachFeatureAtCoordinate\",\n    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {\n      var result;\n      var viewState = frameState.viewState;\n\n      /**\n       * @param {boolean} managed Managed layer.\n       * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n       * @param {import(\"../layer/Layer.js\").default} layer Layer.\n       * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n       * @return {T|undefined} Callback result.\n       */\n      function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n        return callback.call(thisArg, feature, managed ? layer : null, geometry);\n      }\n      var projection = viewState.projection;\n      var translatedCoordinate = wrapX(coordinate.slice(), projection);\n      var offsets = [[0, 0]];\n      if (projection.canWrapX() && checkWrapped) {\n        var projectionExtent = projection.getExtent();\n        var worldWidth = getWidth(projectionExtent);\n        offsets.push([-worldWidth, 0], [worldWidth, 0]);\n      }\n      var layerStates = frameState.layerStatesArray;\n      var numLayers = layerStates.length;\n      var matches = /** @type {Array<HitMatch<T>>} */[];\n      var tmpCoord = [];\n      for (var i = 0; i < offsets.length; i++) {\n        for (var j = numLayers - 1; j >= 0; --j) {\n          var layerState = layerStates[j];\n          var layer = layerState.layer;\n          if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {\n            var layerRenderer = layer.getRenderer();\n            var source = layer.getSource();\n            if (layerRenderer && source) {\n              var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;\n              var _callback = forEachFeatureAtCoordinate.bind(null, layerState.managed);\n              tmpCoord[0] = coordinates[0] + offsets[i][0];\n              tmpCoord[1] = coordinates[1] + offsets[i][1];\n              result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, _callback, matches);\n            }\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n      if (matches.length === 0) {\n        return undefined;\n      }\n      var order = 1 / matches.length;\n      matches.forEach(function (m, i) {\n        return m.distanceSq += i * order;\n      });\n      matches.sort(function (a, b) {\n        return a.distanceSq - b.distanceSq;\n      });\n      matches.some(function (m) {\n        return result = m.callback(m.feature, m.layer, m.geometry);\n      });\n      return result;\n    }\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {boolean} checkWrapped Check for wrapped geometries.\n     * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n     *     function, only layers which are visible and for which this function\n     *     returns `true` will be tested for features.  By default, all visible\n     *     layers will be tested.\n     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n     * @return {boolean} Is there a feature at the given coordinate?\n     * @template U\n     */\n  }, {\n    key: \"hasFeatureAtCoordinate\",\n    value: function hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {\n      var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);\n      return hasFeature !== undefined;\n    }\n    /**\n     * @return {import(\"../Map.js\").default} Map.\n     */\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return this.map_;\n    }\n    /**\n     * Render.\n     * @abstract\n     * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n     */\n  }, {\n    key: \"renderFrame\",\n    value: function renderFrame(frameState) {\n      abstract();\n    }\n    /**\n     * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n  }, {\n    key: \"scheduleExpireIconCache\",\n    value: function scheduleExpireIconCache(frameState) {\n      if (iconImageCache.canExpireCache()) {\n        frameState.postRenderFunctions.push(expireIconCache);\n      }\n    }\n  }]);\n  return MapRenderer;\n}(Disposable);\n/**\n * @param {import(\"../Map.js\").default} map Map.\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\nexport default MapRenderer;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\nimport { createEmpty, createOrUpdateEmpty, getHeight, returnOrUpdate } from '../extent.js';\nimport { get as getProjection, getTransform } from '../proj.js';\nimport { memoizeOne } from '../functions.js';\nimport { transform2D } from './flat/transform.js';\n\n/**\n * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available.\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, or `'Circle'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nvar Geometry = /*#__PURE__*/function (_BaseObject) {\n  _inherits(Geometry, _BaseObject);\n  function Geometry() {\n    var _this;\n    _classCallCheck(this, Geometry);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Geometry).call(this));\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    _this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.simplifiedGeometryRevision = 0;\n\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} revision The geometry revision.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, transform) {\n      if (!transform) {\n        return this.getSimplifiedGeometry(squaredTolerance);\n      }\n      var clone = this.clone();\n      clone.applyTransform(transform);\n      return clone.getSimplifiedGeometry(squaredTolerance);\n    });\n    return _this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {Geometry} Simplified geometry.\n   */\n  _createClass(Geometry, [{\n    key: \"simplifyTransformed\",\n    value: function simplifyTransformed(squaredTolerance, transform) {\n      return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform);\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @abstract\n     * @return {!Geometry} Clone.\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return abstract();\n    }\n    /**\n     * @abstract\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n  }, {\n    key: \"closestPointXY\",\n    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n      return abstract();\n    }\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n  }, {\n    key: \"containsXY\",\n    value: function containsXY(x, y) {\n      var coord = this.getClosestPoint([x, y]);\n      return coord[0] === x && coord[1] === y;\n    }\n    /**\n     * Return the closest point of the geometry to the passed point as\n     * {@link module:ol/coordinate~Coordinate coordinate}.\n     * @param {import(\"../coordinate.js\").Coordinate} point Point.\n     * @param {import(\"../coordinate.js\").Coordinate} [closestPoint] Closest point.\n     * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n     * @api\n     */\n  }, {\n    key: \"getClosestPoint\",\n    value: function getClosestPoint(point, closestPoint) {\n      closestPoint = closestPoint ? closestPoint : [NaN, NaN];\n      this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n      return closestPoint;\n    }\n    /**\n     * Returns true if this geometry includes the specified coordinate. If the\n     * coordinate is on the boundary of the geometry, returns false.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains coordinate.\n     * @api\n     */\n  }, {\n    key: \"intersectsCoordinate\",\n    value: function intersectsCoordinate(coordinate) {\n      return this.containsXY(coordinate[0], coordinate[1]);\n    }\n    /**\n     * @abstract\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n  }, {\n    key: \"computeExtent\",\n    value: function computeExtent(extent) {\n      return abstract();\n    }\n    /**\n     * Get the extent of the geometry.\n     * @param {import(\"../extent.js\").Extent} [extent] Extent.\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     * @api\n     */\n  }, {\n    key: \"getExtent\",\n    value: function getExtent(extent) {\n      if (this.extentRevision_ != this.getRevision()) {\n        var _extent = this.computeExtent(this.extent_);\n        if (isNaN(_extent[0]) || isNaN(_extent[1])) {\n          createOrUpdateEmpty(_extent);\n        }\n        this.extentRevision_ = this.getRevision();\n      }\n      return returnOrUpdate(this.extent_, extent);\n    }\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} angle Rotation angle in radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, anchor) {\n      abstract();\n    }\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, anchor) {\n      abstract();\n    }\n    /**\n     * Create a simplified version of this geometry.  For linestrings, this uses\n     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n     * algorithm.  For polygons, a quantization-based\n     * simplification is used to preserve topology.\n     * @param {number} tolerance The tolerance distance for simplification.\n     * @return {Geometry} A new, simplified version of the original geometry.\n     * @api\n     */\n  }, {\n    key: \"simplify\",\n    value: function simplify(tolerance) {\n      return this.getSimplifiedGeometry(tolerance * tolerance);\n    }\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker\n     * algorithm.\n     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n     * @abstract\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Geometry} Simplified geometry.\n     */\n  }, {\n    key: \"getSimplifiedGeometry\",\n    value: function getSimplifiedGeometry(squaredTolerance) {\n      return abstract();\n    }\n    /**\n     * Get the type of this geometry.\n     * @abstract\n     * @return {Type} Geometry type.\n     */\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return abstract();\n    }\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @abstract\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     */\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform(transformFn) {\n      abstract();\n    }\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @abstract\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     */\n  }, {\n    key: \"intersectsExtent\",\n    value: function intersectsExtent(extent) {\n      return abstract();\n    }\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @abstract\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n  }, {\n    key: \"translate\",\n    value: function translate(deltaX, deltaY) {\n      abstract();\n    }\n    /**\n     * Transform each coordinate of the geometry from one coordinate reference\n     * system to another. The geometry is modified in place.\n     * For example, a line will be transformed to a line and a circle to a circle.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @return {Geometry} This geometry.  Note that original geometry is\n     *     modified in place.\n     * @api\n     */\n  }, {\n    key: \"transform\",\n    value: function transform(source, destination) {\n      /** @type {import(\"../proj/Projection.js\").default} */\n      var sourceProj = getProjection(source);\n      var transformFn = sourceProj.getUnits() == 'tile-pixels' ? function (inCoordinates, outCoordinates, stride) {\n        var pixelExtent = sourceProj.getExtent();\n        var projectedExtent = sourceProj.getWorldExtent();\n        var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n        composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n        transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n        return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n      } : getTransform(sourceProj, destination);\n      this.applyTransform(transformFn);\n      return this;\n    }\n  }]);\n  return Geometry;\n}(BaseObject);\nexport default Geometry;","map":null,"metadata":{},"sourceType":"module"}
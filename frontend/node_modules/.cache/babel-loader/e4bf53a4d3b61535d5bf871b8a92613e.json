{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\nvar CanvasBuilder = /*#__PURE__*/function (_VectorContext) {\n  _inherits(CanvasBuilder, _VectorContext);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this;\n    _classCallCheck(this, CanvasBuilder);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasBuilder).call(this));\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    _this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    _this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    _this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    _this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    _this.coordinates = [];\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n    _this.tmpCoordinate_ = [];\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    _this.hitDetectionInstructions = [];\n\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    _this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */{};\n    return _this;\n  }\n\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  _createClass(CanvasBuilder, [{\n    key: \"applyPixelRatio\",\n    value: function applyPixelRatio(dashArray) {\n      var pixelRatio = this.pixelRatio;\n      return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n        return dash * pixelRatio;\n      });\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} stride Stride.\n     * @protected\n     * @return {number} My end\n     */\n  }, {\n    key: \"appendFlatPointCoordinates\",\n    value: function appendFlatPointCoordinates(flatCoordinates, stride) {\n      var extent = this.getBufferedMaxExtent();\n      var tmpCoord = this.tmpCoordinate_;\n      var coordinates = this.coordinates;\n      var myEnd = coordinates.length;\n      for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n        tmpCoord[0] = flatCoordinates[i];\n        tmpCoord[1] = flatCoordinates[i + 1];\n        if (containsCoordinate(extent, tmpCoord)) {\n          coordinates[myEnd++] = tmpCoord[0];\n          coordinates[myEnd++] = tmpCoord[1];\n        }\n      }\n      return myEnd;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {boolean} closed Last input coordinate equals first.\n     * @param {boolean} skipFirst Skip first coordinate.\n     * @protected\n     * @return {number} My end.\n     */\n  }, {\n    key: \"appendFlatLineCoordinates\",\n    value: function appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n      var coordinates = this.coordinates;\n      var myEnd = coordinates.length;\n      var extent = this.getBufferedMaxExtent();\n      if (skipFirst) {\n        offset += stride;\n      }\n      var lastXCoord = flatCoordinates[offset];\n      var lastYCoord = flatCoordinates[offset + 1];\n      var nextCoord = this.tmpCoordinate_;\n      var skipped = true;\n      var i, lastRel, nextRel;\n      for (i = offset + stride; i < end; i += stride) {\n        nextCoord[0] = flatCoordinates[i];\n        nextCoord[1] = flatCoordinates[i + 1];\n        nextRel = coordinateRelationship(extent, nextCoord);\n        if (nextRel !== lastRel) {\n          if (skipped) {\n            coordinates[myEnd++] = lastXCoord;\n            coordinates[myEnd++] = lastYCoord;\n            skipped = false;\n          }\n          coordinates[myEnd++] = nextCoord[0];\n          coordinates[myEnd++] = nextCoord[1];\n        } else if (nextRel === Relationship.INTERSECTING) {\n          coordinates[myEnd++] = nextCoord[0];\n          coordinates[myEnd++] = nextCoord[1];\n          skipped = false;\n        } else {\n          skipped = true;\n        }\n        lastXCoord = nextCoord[0];\n        lastYCoord = nextCoord[1];\n        lastRel = nextRel;\n      }\n\n      // Last coordinate equals first or only one point to append:\n      if (closed && skipped || i === offset + stride) {\n        coordinates[myEnd++] = lastXCoord;\n        coordinates[myEnd++] = lastYCoord;\n      }\n      return myEnd;\n    }\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {Array<number>} builderEnds Builder ends.\n     * @return {number} Offset.\n     */\n  }, {\n    key: \"drawCustomCoordinates_\",\n    value: function drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n        builderEnds.push(builderEnd);\n        offset = end;\n      }\n      return offset;\n    }\n    /**\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {Function} renderer Renderer.\n     * @param {Function} hitDetectionRenderer Renderer.\n     */\n  }, {\n    key: \"drawCustom\",\n    value: function drawCustom(geometry, feature, renderer, hitDetectionRenderer) {\n      this.beginGeometry(geometry, feature);\n      var type = geometry.getType();\n      var stride = geometry.getStride();\n      var builderBegin = this.coordinates.length;\n      var flatCoordinates, builderEnd, builderEnds, builderEndss;\n      var offset;\n      switch (type) {\n        case 'MultiPolygon':\n          flatCoordinates = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getOrientedFlatCoordinates();\n          builderEndss = [];\n          var endss = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getEndss();\n          offset = 0;\n          for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var myEnds = [];\n            offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n            builderEndss.push(myEnds);\n          }\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, inflateMultiCoordinatesArray]);\n          break;\n        case 'Polygon':\n        case 'MultiLineString':\n          builderEnds = [];\n          flatCoordinates = type == 'Polygon' ? /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n          offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */geometry.getEnds(), stride, builderEnds);\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, inflateCoordinatesArray]);\n          break;\n        case 'LineString':\n        case 'Circle':\n          flatCoordinates = geometry.getFlatCoordinates();\n          builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n          break;\n        case 'MultiPoint':\n          flatCoordinates = geometry.getFlatCoordinates();\n          builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n          if (builderEnd > builderBegin) {\n            this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n            this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n          }\n          break;\n        case 'Point':\n          flatCoordinates = geometry.getFlatCoordinates();\n          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n          builderEnd = this.coordinates.length;\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);\n          break;\n        default:\n      }\n      this.endGeometry(feature);\n    }\n    /**\n     * @protected\n     * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n  }, {\n    key: \"beginGeometry\",\n    value: function beginGeometry(geometry, feature) {\n      this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n      this.instructions.push(this.beginGeometryInstruction1_);\n      this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n      this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n    }\n    /**\n     * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return {\n        instructions: this.instructions,\n        hitDetectionInstructions: this.hitDetectionInstructions,\n        coordinates: this.coordinates\n      };\n    }\n    /**\n     * Reverse the hit detection instructions.\n     */\n  }, {\n    key: \"reverseHitDetectionInstructions\",\n    value: function reverseHitDetectionInstructions() {\n      var hitDetectionInstructions = this.hitDetectionInstructions;\n      // step 1 - reverse array\n      hitDetectionInstructions.reverse();\n      // step 2 - reverse instructions within geometry blocks\n      var i;\n      var n = hitDetectionInstructions.length;\n      var instruction;\n      var type;\n      var begin = -1;\n      for (i = 0; i < n; ++i) {\n        instruction = hitDetectionInstructions[i];\n        type = /** @type {import(\"./Instruction.js\").default} */instruction[0];\n        if (type == CanvasInstruction.END_GEOMETRY) {\n          begin = i;\n        } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n          instruction[2] = i;\n          reverseSubArray(this.hitDetectionInstructions, begin, i);\n          begin = -1;\n        }\n      }\n    }\n    /**\n     * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n     * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n     */\n  }, {\n    key: \"setFillStrokeStyle\",\n    value: function setFillStrokeStyle(fillStyle, strokeStyle) {\n      var state = this.state;\n      if (fillStyle) {\n        var fillStyleColor = fillStyle.getColor();\n        state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n      } else {\n        state.fillStyle = undefined;\n      }\n      if (strokeStyle) {\n        var strokeStyleColor = strokeStyle.getColor();\n        state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n        var strokeStyleLineCap = strokeStyle.getLineCap();\n        state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n        var strokeStyleLineDash = strokeStyle.getLineDash();\n        state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n        state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n        var strokeStyleLineJoin = strokeStyle.getLineJoin();\n        state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n        var strokeStyleWidth = strokeStyle.getWidth();\n        state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n        state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n        if (state.lineWidth > this.maxLineWidth) {\n          this.maxLineWidth = state.lineWidth;\n          // invalidate the buffered max extent cache\n          this.bufferedMaxExtent_ = null;\n        }\n      } else {\n        state.strokeStyle = undefined;\n        state.lineCap = undefined;\n        state.lineDash = null;\n        state.lineDashOffset = undefined;\n        state.lineJoin = undefined;\n        state.lineWidth = undefined;\n        state.miterLimit = undefined;\n      }\n    }\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Fill instruction.\n     */\n  }, {\n    key: \"createFill\",\n    value: function createFill(state) {\n      var fillStyle = state.fillStyle;\n      /** @type {Array<*>} */\n      var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n      if (typeof fillStyle !== 'string') {\n        // Fill is a pattern or gradient - align it!\n        fillInstruction.push(true);\n      }\n      return fillInstruction;\n    }\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     */\n  }, {\n    key: \"applyStroke\",\n    value: function applyStroke(state) {\n      this.instructions.push(this.createStroke(state));\n    }\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Stroke instruction.\n     */\n  }, {\n    key: \"createStroke\",\n    value: function createStroke(state) {\n      return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n    }\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n     */\n  }, {\n    key: \"updateFillStyle\",\n    value: function updateFillStyle(state, createFill) {\n      var fillStyle = state.fillStyle;\n      if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n        if (fillStyle !== undefined) {\n          this.instructions.push(createFill.call(this, state));\n        }\n        state.currentFillStyle = fillStyle;\n      }\n    }\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n     */\n  }, {\n    key: \"updateStrokeStyle\",\n    value: function updateStrokeStyle(state, applyStroke) {\n      var strokeStyle = state.strokeStyle;\n      var lineCap = state.lineCap;\n      var lineDash = state.lineDash;\n      var lineDashOffset = state.lineDashOffset;\n      var lineJoin = state.lineJoin;\n      var lineWidth = state.lineWidth;\n      var miterLimit = state.miterLimit;\n      if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n        if (strokeStyle !== undefined) {\n          applyStroke.call(this, state);\n        }\n        state.currentStrokeStyle = strokeStyle;\n        state.currentLineCap = lineCap;\n        state.currentLineDash = lineDash;\n        state.currentLineDashOffset = lineDashOffset;\n        state.currentLineJoin = lineJoin;\n        state.currentLineWidth = lineWidth;\n        state.currentMiterLimit = miterLimit;\n      }\n    }\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n  }, {\n    key: \"endGeometry\",\n    value: function endGeometry(feature) {\n      this.beginGeometryInstruction1_[2] = this.instructions.length;\n      this.beginGeometryInstruction1_ = null;\n      this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n      this.beginGeometryInstruction2_ = null;\n      var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n      this.instructions.push(endGeometryInstruction);\n      this.hitDetectionInstructions.push(endGeometryInstruction);\n    }\n    /**\n     * Get the buffered rendering extent.  Rendering will be clipped to the extent\n     * provided to the constructor.  To account for symbolizers that may intersect\n     * this extent, we calculate a buffered extent (e.g. based on stroke width).\n     * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n     * @protected\n     */\n  }, {\n    key: \"getBufferedMaxExtent\",\n    value: function getBufferedMaxExtent() {\n      if (!this.bufferedMaxExtent_) {\n        this.bufferedMaxExtent_ = clone(this.maxExtent);\n        if (this.maxLineWidth > 0) {\n          var width = this.resolution * (this.maxLineWidth + 1) / 2;\n          buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n        }\n      }\n      return this.bufferedMaxExtent_;\n    }\n  }]);\n  return CanvasBuilder;\n}(VectorContext);\nexport default CanvasBuilder;","map":null,"metadata":{},"sourceType":"module"}
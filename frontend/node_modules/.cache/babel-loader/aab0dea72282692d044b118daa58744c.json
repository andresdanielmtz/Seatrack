{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /*#__PURE__*/function (_Tile) {\n  _inherits(ReprojTile, _Tile);\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {boolean} [interpolate] Use linear interpolation when resampling.\n   */\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, interpolate) {\n    var _this;\n    _classCallCheck(this, ReprojTile);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReprojTile).call(this, tileCoord, TileState.IDLE, {\n      interpolate: !!interpolate\n    }));\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../ImageTile.js\").default>}\n     */\n    _this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    _this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    var errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n    return _this;\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  _createClass(ReprojTile, [{\n    key: \"getImage\",\n    value: function getImage() {\n      return this.canvas_;\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"reproject_\",\n    value: function reproject_() {\n      var _this2 = this;\n      var sources = [];\n      this.sourceTiles_.forEach(function (tile) {\n        if (tile && tile.getState() == TileState.LOADED) {\n          sources.push({\n            extent: _this2.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n            image: tile.getImage()\n          });\n        }\n      });\n      this.sourceTiles_.length = 0;\n      if (sources.length === 0) {\n        this.state = TileState.ERROR;\n      } else {\n        var z = this.wrappedTileCoord_[0];\n        var size = this.targetTileGrid_.getTileSize(z);\n        var width = typeof size === 'number' ? size : size[0];\n        var height = typeof size === 'number' ? size : size[1];\n        var targetResolution = this.targetTileGrid_.getResolution(z);\n        var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n        var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n        this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n        this.state = TileState.LOADED;\n      }\n      this.changed();\n    }\n    /**\n     * Load not yet loaded URI.\n     */\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this3 = this;\n      if (this.state == TileState.IDLE) {\n        this.state = TileState.LOADING;\n        this.changed();\n        var leftToLoad = 0;\n        this.sourcesListenerKeys_ = [];\n        this.sourceTiles_.forEach(function (tile) {\n          var state = tile.getState();\n          if (state == TileState.IDLE || state == TileState.LOADING) {\n            leftToLoad++;\n            var sourceListenKey = listen(tile, EventType.CHANGE, function (e) {\n              var state = tile.getState();\n              if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            }, _this3);\n            _this3.sourcesListenerKeys_.push(sourceListenKey);\n          }\n        });\n        if (leftToLoad === 0) {\n          setTimeout(this.reproject_.bind(this), 0);\n        } else {\n          this.sourceTiles_.forEach(function (tile, i, arr) {\n            var state = tile.getState();\n            if (state == TileState.IDLE) {\n              tile.load();\n            }\n          });\n        }\n      }\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"unlistenSources_\",\n    value: function unlistenSources_() {\n      this.sourcesListenerKeys_.forEach(unlistenByKey);\n      this.sourcesListenerKeys_ = null;\n    }\n    /**\n     * Remove from the cache due to expiry\n     */\n  }, {\n    key: \"release\",\n    value: function release() {\n      if (this.canvas_) {\n        releaseCanvas(this.canvas_.getContext('2d'));\n        canvasPool.push(this.canvas_);\n        this.canvas_ = null;\n      }\n      _get(_getPrototypeOf(ReprojTile.prototype), \"release\", this).call(this);\n    }\n  }]);\n  return ReprojTile;\n}(Tile);\nexport default ReprojTile;","map":null,"metadata":{},"sourceType":"module"}
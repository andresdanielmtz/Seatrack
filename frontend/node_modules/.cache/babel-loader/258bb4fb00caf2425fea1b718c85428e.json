{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction } from './Instruction.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\nvar CanvasPolygonBuilder = /*#__PURE__*/function (_CanvasBuilder) {\n  _inherits(CanvasPolygonBuilder, _CanvasBuilder);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    _classCallCheck(this, CanvasPolygonBuilder);\n    return _possibleConstructorReturn(this, _getPrototypeOf(CanvasPolygonBuilder).call(this, tolerance, maxExtent, resolution, pixelRatio));\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  _createClass(CanvasPolygonBuilder, [{\n    key: \"drawFlatCoordinatess_\",\n    value: function drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n      var state = this.state;\n      var fill = state.fillStyle !== undefined;\n      var stroke = state.strokeStyle !== undefined;\n      var numEnds = ends.length;\n      this.instructions.push(beginPathInstruction);\n      this.hitDetectionInstructions.push(beginPathInstruction);\n      for (var i = 0; i < numEnds; ++i) {\n        var end = ends[i];\n        var myBegin = this.coordinates.length;\n        var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n        var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n        this.instructions.push(moveToLineToInstruction);\n        this.hitDetectionInstructions.push(moveToLineToInstruction);\n        if (stroke) {\n          // Performance optimization: only call closePath() when we have a stroke.\n          // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n          this.instructions.push(closePathInstruction);\n          this.hitDetectionInstructions.push(closePathInstruction);\n        }\n        offset = end;\n      }\n      if (fill) {\n        this.instructions.push(fillInstruction);\n        this.hitDetectionInstructions.push(fillInstruction);\n      }\n      if (stroke) {\n        this.instructions.push(strokeInstruction);\n        this.hitDetectionInstructions.push(strokeInstruction);\n      }\n      return offset;\n    }\n    /**\n     * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n     * @param {import(\"../../Feature.js\").default} feature Feature.\n     */\n  }, {\n    key: \"drawCircle\",\n    value: function drawCircle(circleGeometry, feature) {\n      var state = this.state;\n      var fillStyle = state.fillStyle;\n      var strokeStyle = state.strokeStyle;\n      if (fillStyle === undefined && strokeStyle === undefined) {\n        return;\n      }\n      this.setFillStrokeStyles_();\n      this.beginGeometry(circleGeometry, feature);\n      if (state.fillStyle !== undefined) {\n        this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n      }\n      if (state.strokeStyle !== undefined) {\n        this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n      }\n      var flatCoordinates = circleGeometry.getFlatCoordinates();\n      var stride = circleGeometry.getStride();\n      var myBegin = this.coordinates.length;\n      this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n      this.instructions.push(beginPathInstruction, circleInstruction);\n      this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n      if (state.fillStyle !== undefined) {\n        this.instructions.push(fillInstruction);\n        this.hitDetectionInstructions.push(fillInstruction);\n      }\n      if (state.strokeStyle !== undefined) {\n        this.instructions.push(strokeInstruction);\n        this.hitDetectionInstructions.push(strokeInstruction);\n      }\n      this.endGeometry(feature);\n    }\n    /**\n     * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n  }, {\n    key: \"drawPolygon\",\n    value: function drawPolygon(polygonGeometry, feature) {\n      var state = this.state;\n      var fillStyle = state.fillStyle;\n      var strokeStyle = state.strokeStyle;\n      if (fillStyle === undefined && strokeStyle === undefined) {\n        return;\n      }\n      this.setFillStrokeStyles_();\n      this.beginGeometry(polygonGeometry, feature);\n      if (state.fillStyle !== undefined) {\n        this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n      }\n      if (state.strokeStyle !== undefined) {\n        this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n      }\n      var ends = polygonGeometry.getEnds();\n      var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n      var stride = polygonGeometry.getStride();\n      this.drawFlatCoordinatess_(flatCoordinates, 0, /** @type {Array<number>} */ends, stride);\n      this.endGeometry(feature);\n    }\n    /**\n     * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n  }, {\n    key: \"drawMultiPolygon\",\n    value: function drawMultiPolygon(multiPolygonGeometry, feature) {\n      var state = this.state;\n      var fillStyle = state.fillStyle;\n      var strokeStyle = state.strokeStyle;\n      if (fillStyle === undefined && strokeStyle === undefined) {\n        return;\n      }\n      this.setFillStrokeStyles_();\n      this.beginGeometry(multiPolygonGeometry, feature);\n      if (state.fillStyle !== undefined) {\n        this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n      }\n      if (state.strokeStyle !== undefined) {\n        this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n      }\n      var endss = multiPolygonGeometry.getEndss();\n      var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n      var stride = multiPolygonGeometry.getStride();\n      var offset = 0;\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n      }\n      this.endGeometry(feature);\n    }\n    /**\n     * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.reverseHitDetectionInstructions();\n      this.state = null;\n      // We want to preserve topology when drawing polygons.  Polygons are\n      // simplified using quantization and point elimination. However, we might\n      // have received a mix of quantized and non-quantized geometries, so ensure\n      // that all are quantized by quantizing all coordinates in the batch.\n      var tolerance = this.tolerance;\n      if (tolerance !== 0) {\n        var coordinates = this.coordinates;\n        for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n          coordinates[i] = snap(coordinates[i], tolerance);\n        }\n      }\n      return _get(_getPrototypeOf(CanvasPolygonBuilder.prototype), \"finish\", this).call(this);\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"setFillStrokeStyles_\",\n    value: function setFillStrokeStyles_() {\n      var state = this.state;\n      var fillStyle = state.fillStyle;\n      if (fillStyle !== undefined) {\n        this.updateFillStyle(state, this.createFill);\n      }\n      if (state.strokeStyle !== undefined) {\n        this.updateStrokeStyle(state, this.applyStroke);\n      }\n    }\n  }]);\n  return CanvasPolygonBuilder;\n}(CanvasBuilder);\nexport default CanvasPolygonBuilder;","map":null,"metadata":{},"sourceType":"module"}
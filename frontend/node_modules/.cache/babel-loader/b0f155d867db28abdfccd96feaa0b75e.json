{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, toString as toTransformString } from '../../transform.js';\nimport { ascending } from '../../array.js';\nimport { containsCoordinate, createEmpty, equals, getHeight, getIntersection, getRotatedViewport, getTopLeft, getWidth, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nvar CanvasTileLayerRenderer = /*#__PURE__*/function (_CanvasLayerRenderer) {\n  _inherits(CanvasTileLayerRenderer, _CanvasLayerRenderer);\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  function CanvasTileLayerRenderer(tileLayer) {\n    var _this;\n    _classCallCheck(this, CanvasTileLayerRenderer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasTileLayerRenderer).call(this, tileLayer));\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    _this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    _this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    _this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    _this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    return _this;\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  _createClass(CanvasTileLayerRenderer, [{\n    key: \"isDrawableTile\",\n    value: function isDrawableTile(tile) {\n      var tileLayer = this.getLayer();\n      var tileState = tile.getState();\n      var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n      return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n    }\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {!import(\"../../Tile.js\").default} Tile.\n     */\n  }, {\n    key: \"getTile\",\n    value: function getTile(z, x, y, frameState) {\n      var pixelRatio = frameState.pixelRatio;\n      var projection = frameState.viewState.projection;\n      var tileLayer = this.getLayer();\n      var tileSource = tileLayer.getSource();\n      var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n      if (tile.getState() == TileState.ERROR) {\n        if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n          // Preloaded tiles for lower resolutions might have finished loading.\n          this.newTiles_ = true;\n        }\n      }\n      if (!this.isDrawableTile(tile)) {\n        tile = tile.getInterimTile();\n      }\n      return tile;\n    }\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @return {Uint8ClampedArray} Data at the pixel location.\n     */\n  }, {\n    key: \"getData\",\n    value: function getData(pixel) {\n      var frameState = this.frameState;\n      if (!frameState) {\n        return null;\n      }\n      var layer = this.getLayer();\n      var coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n      var layerExtent = layer.getExtent();\n      if (layerExtent) {\n        if (!containsCoordinate(layerExtent, coordinate)) {\n          return null;\n        }\n      }\n      var pixelRatio = frameState.pixelRatio;\n      var projection = frameState.viewState.projection;\n      var viewState = frameState.viewState;\n      var source = layer.getRenderSource();\n      var tileGrid = source.getTileGridForProjection(viewState.projection);\n      var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n      for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n        var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n        var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);\n        if (!(tile instanceof ImageTile || tile instanceof ReprojTile) || tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {\n          return null;\n        }\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        var tileOrigin = tileGrid.getOrigin(z);\n        var tileSize = toSize(tileGrid.getTileSize(z));\n        var tileResolution = tileGrid.getResolution(z);\n        var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n        var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n        var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n        return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n      }\n      return null;\n    }\n    /**\n     * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @param {number} zoom Zoom level.\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean|void} If `false`, the tile will not be considered loaded.\n     */\n  }, {\n    key: \"loadedTileCallback\",\n    value: function loadedTileCallback(tiles, zoom, tile) {\n      if (this.isDrawableTile(tile)) {\n        return _get(_getPrototypeOf(CanvasTileLayerRenderer.prototype), \"loadedTileCallback\", this).call(this, tiles, zoom, tile);\n      }\n      return false;\n    }\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n  }, {\n    key: \"prepareFrame\",\n    value: function prepareFrame(frameState) {\n      return !!this.getLayer().getSource();\n    }\n    /**\n     * Render the layer.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n  }, {\n    key: \"renderFrame\",\n    value: function renderFrame(frameState, target) {\n      var layerState = frameState.layerStatesArray[frameState.layerIndex];\n      var viewState = frameState.viewState;\n      var projection = viewState.projection;\n      var viewResolution = viewState.resolution;\n      var viewCenter = viewState.center;\n      var rotation = viewState.rotation;\n      var pixelRatio = frameState.pixelRatio;\n      var tileLayer = this.getLayer();\n      var tileSource = tileLayer.getSource();\n      var sourceRevision = tileSource.getRevision();\n      var tileGrid = tileSource.getTileGridForProjection(projection);\n      var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n      var tileResolution = tileGrid.getResolution(z);\n      var extent = frameState.extent;\n      var resolution = frameState.viewState.resolution;\n      var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n      // desired dimensions of the canvas in pixels\n      var width = Math.round(getWidth(extent) / resolution * pixelRatio);\n      var height = Math.round(getHeight(extent) / resolution * pixelRatio);\n      var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n      if (layerExtent) {\n        extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n      }\n      var dx = tileResolution * width / 2 / tilePixelRatio;\n      var dy = tileResolution * height / 2 / tilePixelRatio;\n      var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n      /**\n       * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n       */\n      var tilesToDrawByZ = {};\n      tilesToDrawByZ[z] = {};\n      var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n      var tmpExtent = this.tmpExtent;\n      var tmpTileRange = this.tmpTileRange_;\n      this.newTiles_ = false;\n      var viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : undefined;\n      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n            continue;\n          }\n          var tile = this.getTile(z, x, y, frameState);\n          if (this.isDrawableTile(tile)) {\n            var uid = getUid(this);\n            if (tile.getState() == TileState.LOADED) {\n              tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n              var inTransition = tile.inTransition(uid);\n              if (inTransition && layerState.opacity !== 1) {\n                // Skipping transition when layer is not fully opaque avoids visual artifacts.\n                tile.endTransition(uid);\n                inTransition = false;\n              }\n              if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {\n                this.newTiles_ = true;\n              }\n            }\n            if (tile.getAlpha(uid, frameState.time) === 1) {\n              // don't look for alt tiles if alpha is 1\n              continue;\n            }\n          }\n          var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n          var covered = false;\n          if (childTileRange) {\n            covered = findLoadedTiles(z + 1, childTileRange);\n          }\n          if (!covered) {\n            tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n          }\n        }\n      }\n      var canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;\n\n      // set forward and inverse pixel transforms\n      composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n      var canvasTransform = toTransformString(this.pixelTransform);\n      this.useContainer(target, canvasTransform, this.getBackground(frameState));\n      var context = this.context;\n      var canvas = context.canvas;\n      makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n      // set scale transform for calculating tile positions on the canvas\n      composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n      if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n      } else if (!this.containerReused) {\n        context.clearRect(0, 0, width, height);\n      }\n      if (layerExtent) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n      if (!tileSource.getInterpolate()) {\n        context.imageSmoothingEnabled = false;\n      }\n      this.preRender(context, frameState);\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(ascending);\n      var clips, clipZs, currentClip;\n      if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n        zs = zs.reverse();\n      } else {\n        clips = [];\n        clipZs = [];\n      }\n      for (var i = zs.length - 1; i >= 0; --i) {\n        var currentZ = zs[i];\n        var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        var currentResolution = tileGrid.getResolution(currentZ);\n        var currentScale = currentResolution / tileResolution;\n        var _dx = currentTilePixelSize[0] * currentScale * canvasScale;\n        var _dy = currentTilePixelSize[1] * currentScale * canvasScale;\n        var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n        var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n        var origin = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n        var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        var tilesToDraw = tilesToDrawByZ[currentZ];\n        for (var tileCoordKey in tilesToDraw) {\n          var _tile = /** @type {import(\"../../ImageTile.js\").default} */\n          tilesToDraw[tileCoordKey];\n          var tileCoord = _tile.tileCoord;\n\n          // Calculate integer positions and sizes so that tiles align\n          var xIndex = originTileCoord[1] - tileCoord[1];\n          var nextX = Math.round(origin[0] - (xIndex - 1) * _dx);\n          var yIndex = originTileCoord[2] - tileCoord[2];\n          var nextY = Math.round(origin[1] - (yIndex - 1) * _dy);\n          var _x = Math.round(origin[0] - xIndex * _dx);\n          var _y = Math.round(origin[1] - yIndex * _dy);\n          var w = nextX - _x;\n          var h = nextY - _y;\n          var transition = z === currentZ;\n          var _inTransition = transition && _tile.getAlpha(getUid(this), frameState.time) !== 1;\n          var contextSaved = false;\n          if (!_inTransition) {\n            if (clips) {\n              // Clip mask for regions in this tile that already filled by a higher z tile\n              currentClip = [_x, _y, _x + w, _y, _x + w, _y + h, _x, _y + h];\n              for (var _i = 0, ii = clips.length; _i < ii; ++_i) {\n                if (z !== currentZ && currentZ < clipZs[_i]) {\n                  var clip = clips[_i];\n                  if (intersects([_x, _y, _x + w, _y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n                    if (!contextSaved) {\n                      context.save();\n                      contextSaved = true;\n                    }\n                    context.beginPath();\n                    // counter-clockwise (outer ring) for current tile\n                    context.moveTo(currentClip[0], currentClip[1]);\n                    context.lineTo(currentClip[2], currentClip[3]);\n                    context.lineTo(currentClip[4], currentClip[5]);\n                    context.lineTo(currentClip[6], currentClip[7]);\n                    // clockwise (inner ring) for higher z tile\n                    context.moveTo(clip[6], clip[7]);\n                    context.lineTo(clip[4], clip[5]);\n                    context.lineTo(clip[2], clip[3]);\n                    context.lineTo(clip[0], clip[1]);\n                    context.clip();\n                  }\n                }\n              }\n              clips.push(currentClip);\n              clipZs.push(currentZ);\n            } else {\n              context.clearRect(_x, _y, w, h);\n            }\n          }\n          this.drawTileImage(_tile, frameState, _x, _y, w, h, tileGutter, transition);\n          if (clips && !_inTransition) {\n            if (contextSaved) {\n              context.restore();\n            }\n            this.renderedTiles.unshift(_tile);\n          } else {\n            this.renderedTiles.push(_tile);\n          }\n          this.updateUsedTiles(frameState.usedTiles, tileSource, _tile);\n        }\n      }\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution;\n      this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n      this.renderedExtent_ = canvasExtent;\n      this.renderedPixelRatio = pixelRatio;\n      this.renderedProjection = projection;\n      this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n      this.scheduleExpireCache(frameState, tileSource);\n      this.postRender(context, frameState);\n      if (layerState.extent) {\n        context.restore();\n      }\n      context.imageSmoothingEnabled = true;\n      if (canvasTransform !== canvas.style.transform) {\n        canvas.style.transform = canvasTransform;\n      }\n      return this.container;\n    }\n    /**\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {number} x Left of the tile.\n     * @param {number} y Top of the tile.\n     * @param {number} w Width of the tile.\n     * @param {number} h Height of the tile.\n     * @param {number} gutter Tile gutter.\n     * @param {boolean} transition Apply an alpha transition.\n     */\n  }, {\n    key: \"drawTileImage\",\n    value: function drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n      var image = this.getTileImage(tile);\n      if (!image) {\n        return;\n      }\n      var uid = getUid(this);\n      var layerState = frameState.layerStatesArray[frameState.layerIndex];\n      var alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n      var alphaChanged = alpha !== this.context.globalAlpha;\n      if (alphaChanged) {\n        this.context.save();\n        this.context.globalAlpha = alpha;\n      }\n      this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n      if (alphaChanged) {\n        this.context.restore();\n      }\n      if (alpha !== layerState.opacity) {\n        frameState.animate = true;\n      } else if (transition) {\n        tile.endTransition(uid);\n      }\n    }\n    /**\n     * @return {HTMLCanvasElement} Image\n     */\n  }, {\n    key: \"getImage\",\n    value: function getImage() {\n      var context = this.context;\n      return context ? context.canvas : null;\n    }\n    /**\n     * Get the image from a tile.\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n     * @protected\n     */\n  }, {\n    key: \"getTileImage\",\n    value: function getTileImage(tile) {\n      return tile.getImage();\n    }\n    /**\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @protected\n     */\n  }, {\n    key: \"scheduleExpireCache\",\n    value: function scheduleExpireCache(frameState, tileSource) {\n      if (tileSource.canExpireCache()) {\n        /**\n         * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n         * @param {import(\"../../Map.js\").default} map Map.\n         * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n         */\n        var postRenderFunction = function (tileSource, map, frameState) {\n          var tileSourceKey = getUid(tileSource);\n          if (tileSourceKey in frameState.usedTiles) {\n            tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n          }\n        }.bind(null, tileSource);\n        frameState.postRenderFunctions.push( /** @type {import(\"../../Map.js\").PostRenderFunction} */\n        postRenderFunction);\n      }\n    }\n    /**\n     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import('../../Tile.js').default} tile Tile.\n     * @protected\n     */\n  }, {\n    key: \"updateUsedTiles\",\n    value: function updateUsedTiles(usedTiles, tileSource, tile) {\n      // FIXME should we use tilesToDrawByZ instead?\n      var tileSourceKey = getUid(tileSource);\n      if (!(tileSourceKey in usedTiles)) {\n        usedTiles[tileSourceKey] = {};\n      }\n      usedTiles[tileSourceKey][tile.getKey()] = true;\n    }\n    /**\n     * Manage tile pyramid.\n     * This function performs a number of functions related to the tiles at the\n     * current zoom and lower zoom levels:\n     * - registers idle tiles in frameState.wantedTiles so that they are not\n     *   discarded by the tile queue\n     * - enqueues missing tiles\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @param {number} currentZ Current Z.\n     * @param {number} preload Load low resolution tiles up to `preload` levels.\n     * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n     * @protected\n     */\n  }, {\n    key: \"manageTilePyramid\",\n    value: function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {\n      var tileSourceKey = getUid(tileSource);\n      if (!(tileSourceKey in frameState.wantedTiles)) {\n        frameState.wantedTiles[tileSourceKey] = {};\n      }\n      var wantedTiles = frameState.wantedTiles[tileSourceKey];\n      var tileQueue = frameState.tileQueue;\n      var minZoom = tileGrid.getMinZoom();\n      var rotation = frameState.viewState.rotation;\n      var viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;\n      var tileCount = 0;\n      var tile, tileRange, tileResolution, x, y, z;\n      for (z = minZoom; z <= currentZ; ++z) {\n        tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n        tileResolution = tileGrid.getResolution(z);\n        for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n          for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n            if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n              continue;\n            }\n            if (currentZ - z <= preload) {\n              ++tileCount;\n              tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n              if (tile.getState() == TileState.IDLE) {\n                wantedTiles[tile.getKey()] = true;\n                if (!tileQueue.isKeyQueued(tile.getKey())) {\n                  tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n                }\n              }\n              if (tileCallback !== undefined) {\n                tileCallback(tile);\n              }\n            } else {\n              tileSource.useTile(z, x, y, projection);\n            }\n          }\n        }\n      }\n      tileSource.updateCacheSize(tileCount, projection);\n    }\n  }]);\n  return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer);\nexport default CanvasTileLayerRenderer;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/kapigoku/Documents/Cosas/Programacio\\u0301n/Phyton/Seatrack/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n/**\n * @module ol/Map\n */\nimport BaseObject from './Object.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport CompositeMapRenderer from './renderer/Composite.js';\nimport EventType from './events/EventType.js';\nimport Layer from './layer/Layer.js';\nimport LayerGroup, { GroupEvent } from './layer/Group.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport RenderEventType from './render/EventType.js';\nimport TileQueue, { getTilePriority as _getTilePriority } from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { TRUE } from './functions.js';\nimport { apply as applyTransform, create as createTransform } from './transform.js';\nimport { assert } from './asserts.js';\nimport { clone, createOrUpdateEmpty, equals as equalsExtent, getForViewAndSize, isEmpty } from './extent.js';\nimport { defaults as defaultControls } from './control/defaults.js';\nimport { defaults as defaultInteractions } from './interaction/defaults.js';\nimport { equals } from './array.js';\nimport { fromUserCoordinate, toUserCoordinate } from './proj.js';\nimport { getUid } from './util.js';\nimport { hasArea } from './size.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { removeNode } from './dom.js';\nimport { warn } from './console.js';\n\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate Animate.\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform CoordinateToPixelTransform.\n * @property {import(\"rbush\").default} declutterTree DeclutterTree.\n * @property {null|import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [nextExtent] Next extent during an animation series.\n * @property {number} index Index.\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray LayerStatesArray.\n * @property {number} layerIndex LayerIndex.\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.\n * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.\n * @property {import(\"./size.js\").Size} size Size.\n * @property {TileQueue} tileQueue TileQueue.\n * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.\n * @property {Array<number>} viewHints ViewHints.\n * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.\n * @property {string} mapId The id of the map.\n * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.\n */\n\n/**\n * @typedef {function(Map, ?FrameState): any} PostRenderFunction\n */\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>): boolean} [layerFilter] Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels\n * inside the radius around the given position will be checked for features.\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\n */\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls] Controls.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions] Interactions.\n * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.\n * @property {Collection<import(\"./Overlay.js\").default>} overlays Overlays.\n * @property {Object<string, *>} values Values.\n */\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<MapObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapBrowserEventType\").Types, import(\"./MapBrowserEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapEventType\").Types, import(\"./MapEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./render/EventType\").MapRenderEventTypes, import(\"./render/Event\").default, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|MapObjectEventTypes|\n *      import(\"./MapBrowserEventType\").Types|import(\"./MapEventType\").Types|\n *      import(\"./render/EventType\").MapRenderEventTypes, Return>} MapEventHandler\n */\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control/defaults.defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction/defaults.defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered. If passed by element, the container can be in a secondary document.\n * **Note:** CSS `transform` support for the target element is limited to `scale`.\n * @property {View|Promise<import(\"./View.js\").ViewOptions>} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n/**\n * @param {import(\"./layer/Base.js\").default} layer Layer.\n */\nfunction removeLayerMapProperty(layer) {\n  if (layer instanceof Layer) {\n    layer.setMapInternal(null);\n    return;\n  }\n  if (layer instanceof LayerGroup) {\n    layer.getLayers().forEach(removeLayerMapProperty);\n  }\n}\n\n/**\n * @param {import(\"./layer/Base.js\").default} layer Layer.\n * @param {Map} map Map.\n */\nfunction setLayerMapProperty(layer, map) {\n  if (layer instanceof Layer) {\n    layer.setMapInternal(map);\n    return;\n  }\n  if (layer instanceof LayerGroup) {\n    var layers = layer.getLayers().getArray();\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n      setLayerMapProperty(layers[i], map);\n    }\n  }\n}\n\n/**\n * @classdesc\n * The map is the core component of OpenLayers. For a map to render, a view,\n * one or more layers, and a target container are needed:\n *\n *     import Map from 'ol/Map.js';\n *     import View from 'ol/View.js';\n *     import TileLayer from 'ol/layer/Tile.js';\n *     import OSM from 'ol/source/OSM.js';\n *\n *     const map = new Map({\n *       view: new View({\n *         center: [0, 0],\n *         zoom: 1,\n *       }),\n *       layers: [\n *         new TileLayer({\n *           source: new OSM(),\n *         }),\n *       ],\n *       target: 'map',\n *     });\n *\n * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to\n * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM\n * element with the id `map`.\n *\n * The constructor places a viewport container (with CSS class name\n * `ol-viewport`) in the target element (see `getViewport()`), and then two\n * further elements within the viewport: one with CSS class name\n * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\n * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\n * option of {@link module:ol/Overlay~Overlay} for the difference). The map\n * itself is placed in a further element within the viewport.\n *\n * Layers are stored as a {@link module:ol/Collection~Collection} in\n * layerGroups. A top-level group is provided by the library. This is what is\n * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the\n * options are added to this group, and `addLayer` and `removeLayer` change the\n * layer collection in the group. `getLayers` is a convenience function for\n * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}\n * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the\n * options or added with `addLayer` can be groups, which can contain further\n * groups, and so on.\n *\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n * @fires import(\"./MapEvent.js\").MapEvent\n * @fires import(\"./render/Event.js\").default#precompose\n * @fires import(\"./render/Event.js\").default#postcompose\n * @fires import(\"./render/Event.js\").default#rendercomplete\n * @api\n */\nvar Map = /*#__PURE__*/function (_BaseObject) {\n  _inherits(Map, _BaseObject);\n  /**\n   * @param {MapOptions} [options] Map options.\n   */\n  function Map(options) {\n    var _this;\n    _classCallCheck(this, Map);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Map).call(this));\n    options = options || {};\n\n    /***\n     * @type {MapEventHandler<import(\"./events\").EventsKey>}\n     */\n    _this.on;\n\n    /***\n     * @type {MapEventHandler<import(\"./events\").EventsKey>}\n     */\n    _this.once;\n\n    /***\n     * @type {MapEventHandler<void>}\n     */\n    _this.un;\n    var optionsInternal = createOptionsInternal(options);\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    _this.renderComplete_;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.loaded_ = true;\n\n    /** @private */\n    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n\n    /**\n     * @private\n     * @type {*}\n     */\n    _this.postRenderTimeoutHandle_;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    _this.animationDelayKey_;\n\n    /**\n     * @private\n     */\n    _this.animationDelay_ = _this.animationDelay_.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    _this.coordinateToPixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    _this.pixelToCoordinateTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.frameIndex_ = 0;\n\n    /**\n     * @private\n     * @type {?FrameState}\n     */\n    _this.frameState_ = null;\n\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {import(\"./extent.js\").Extent}\n     */\n    _this.previousExtent_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    _this.viewPropertyListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    _this.viewChangeListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n    _this.layerGroupPropertyListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    _this.viewport_ = document.createElement('div');\n    _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n    _this.viewport_.style.position = 'relative';\n    _this.viewport_.style.overflow = 'hidden';\n    _this.viewport_.style.width = '100%';\n    _this.viewport_.style.height = '100%';\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    _this.overlayContainer_ = document.createElement('div');\n    _this.overlayContainer_.style.position = 'absolute';\n    _this.overlayContainer_.style.zIndex = '0';\n    _this.overlayContainer_.style.width = '100%';\n    _this.overlayContainer_.style.height = '100%';\n    _this.overlayContainer_.style.pointerEvents = 'none';\n    _this.overlayContainer_.className = 'ol-overlaycontainer';\n    _this.viewport_.appendChild(_this.overlayContainer_);\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    _this.overlayContainerStopEvent_ = document.createElement('div');\n    _this.overlayContainerStopEvent_.style.position = 'absolute';\n    _this.overlayContainerStopEvent_.style.zIndex = '0';\n    _this.overlayContainerStopEvent_.style.width = '100%';\n    _this.overlayContainerStopEvent_.style.height = '100%';\n    _this.overlayContainerStopEvent_.style.pointerEvents = 'none';\n    _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);\n\n    /**\n     * @private\n     * @type {MapBrowserEventHandler}\n     */\n    _this.mapBrowserEventHandler_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.moveTolerance_ = options.moveTolerance;\n\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n    _this.targetChangeHandlerKeys_ = null;\n\n    /**\n     * @private\n     * @type {HTMLElement|null}\n     */\n    _this.targetElement_ = null;\n\n    /**\n     * @type {ResizeObserver}\n     */\n    _this.resizeObserver_ = new ResizeObserver(function () {\n      return _this.updateSize();\n    });\n\n    /**\n     * @type {Collection<import(\"./control/Control.js\").default>}\n     * @protected\n     */\n    _this.controls = optionsInternal.controls || defaultControls();\n\n    /**\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n     * @protected\n     */\n    _this.interactions = optionsInternal.interactions || defaultInteractions({\n      onFocusOnly: true\n    });\n\n    /**\n     * @type {Collection<import(\"./Overlay.js\").default>}\n     * @private\n     */\n    _this.overlays_ = optionsInternal.overlays;\n\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object<string, import(\"./Overlay.js\").default>}\n     */\n    _this.overlayIdIndex_ = {};\n\n    /**\n     * @type {import(\"./renderer/Map.js\").default|null}\n     * @private\n     */\n    _this.renderer_ = null;\n\n    /**\n     * @private\n     * @type {!Array<PostRenderFunction>}\n     */\n    _this.postRenderFunctions_ = [];\n\n    /**\n     * @private\n     * @type {TileQueue}\n     */\n    _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_assertThisInitialized(_assertThisInitialized(_this))), _this.handleTileChange_.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n    _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);\n    _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);\n    _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);\n    _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_);\n\n    // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n    _this.setProperties(optionsInternal.values);\n    var map = _assertThisInitialized(_assertThisInitialized(_this));\n    if (options.view && !(options.view instanceof View)) {\n      options.view.then(function (viewOptions) {\n        map.setView(new View(viewOptions));\n      });\n    }\n    _this.controls.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./control/Control.js\").default>} event CollectionEvent\n     */\n    function (event) {\n      event.element.setMap(_assertThisInitialized(_assertThisInitialized(_this)));\n    });\n    _this.controls.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./control/Control.js\").default>} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    });\n    _this.interactions.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./interaction/Interaction.js\").default>} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(_assertThisInitialized(_assertThisInitialized(_this)));\n    });\n    _this.interactions.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./interaction/Interaction.js\").default>} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    });\n    _this.overlays_.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./Overlay.js\").default>} event CollectionEvent.\n     */\n    function (event) {\n      _this.addOverlayInternal_(event.element);\n    });\n    _this.overlays_.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./Overlay.js\").default>} event CollectionEvent.\n     */\n    function (event) {\n      var id = event.element.getId();\n      if (id !== undefined) {\n        delete _this.overlayIdIndex_[id.toString()];\n      }\n      event.element.setMap(null);\n    });\n    _this.controls.forEach(\n    /**\n     * @param {import(\"./control/Control.js\").default} control Control.\n     */\n    function (control) {\n      control.setMap(_assertThisInitialized(_assertThisInitialized(_this)));\n    });\n    _this.interactions.forEach(\n    /**\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n     */\n    function (interaction) {\n      interaction.setMap(_assertThisInitialized(_assertThisInitialized(_this)));\n    });\n    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n    return _this;\n  }\n\n  /**\n   * Add the given control to the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @api\n   */\n  _createClass(Map, [{\n    key: \"addControl\",\n    value: function addControl(control) {\n      this.getControls().push(control);\n    }\n    /**\n     * Add the given interaction to the map. If you want to add an interaction\n     * at another point of the collection use `getInteractions()` and the methods\n     * available on {@link module:ol/Collection~Collection}. This can be used to\n     * stop the event propagation from the handleEvent function. The interactions\n     * get to handle the events in the reverse order of this collection.\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n     * @api\n     */\n  }, {\n    key: \"addInteraction\",\n    value: function addInteraction(interaction) {\n      this.getInteractions().push(interaction);\n    }\n    /**\n     * Adds the given layer to the top of this map. If you want to add a layer\n     * elsewhere in the stack, use `getLayers()` and the methods available on\n     * {@link module:ol/Collection~Collection}.\n     * @param {import(\"./layer/Base.js\").default} layer Layer.\n     * @api\n     */\n  }, {\n    key: \"addLayer\",\n    value: function addLayer(layer) {\n      var layers = this.getLayerGroup().getLayers();\n      layers.push(layer);\n    }\n    /**\n     * @param {import(\"./layer/Group.js\").GroupEvent} event The layer add event.\n     * @private\n     */\n  }, {\n    key: \"handleLayerAdd_\",\n    value: function handleLayerAdd_(event) {\n      setLayerMapProperty(event.layer, this);\n    }\n    /**\n     * Add the given overlay to the map.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @api\n     */\n  }, {\n    key: \"addOverlay\",\n    value: function addOverlay(overlay) {\n      this.getOverlays().push(overlay);\n    }\n    /**\n     * This deals with map's overlay collection changes.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @private\n     */\n  }, {\n    key: \"addOverlayInternal_\",\n    value: function addOverlayInternal_(overlay) {\n      var id = overlay.getId();\n      if (id !== undefined) {\n        this.overlayIdIndex_[id.toString()] = overlay;\n      }\n      overlay.setMap(this);\n    }\n    /**\n     *\n     * Clean up.\n     */\n  }, {\n    key: \"disposeInternal\",\n    value: function disposeInternal() {\n      this.controls.clear();\n      this.interactions.clear();\n      this.overlays_.clear();\n      this.resizeObserver_.disconnect();\n      this.setTarget(null);\n      _get(_getPrototypeOf(Map.prototype), \"disposeInternal\", this).call(this);\n    }\n    /**\n     * Detect features that intersect a pixel on the viewport, and execute a\n     * callback with each intersecting feature. Layers included in the detection can\n     * be configured through the `layerFilter` option in `options`.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {function(import(\"./Feature.js\").FeatureLike, import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>, import(\"./geom/SimpleGeometry.js\").default): T} callback Feature callback. The callback will be\n     *     called with two arguments. The first argument is one\n     *     {@link module:ol/Feature~Feature feature} or\n     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is\n     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n     *     unmanaged layers. To stop detection, callback functions can return a\n     *     truthy value.\n     * @param {AtPixelOptions} [options] Optional options.\n     * @return {T|undefined} Callback result, i.e. the return value of last\n     * callback execution, or the first truthy callback return value.\n     * @template T\n     * @api\n     */\n  }, {\n    key: \"forEachFeatureAtPixel\",\n    value: function forEachFeatureAtPixel(pixel, callback, options) {\n      if (!this.frameState_ || !this.renderer_) {\n        return;\n      }\n      var coordinate = this.getCoordinateFromPixelInternal(pixel);\n      options = options !== undefined ? options : {};\n      var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;\n      var layerFilter = options.layerFilter !== undefined ? options.layerFilter : TRUE;\n      var checkWrapped = options.checkWrapped !== false;\n      return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);\n    }\n    /**\n     * Get all features that intersect a pixel on the viewport.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {AtPixelOptions} [options] Optional options.\n     * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n     * an empty array if none were found.\n     * @api\n     */\n  }, {\n    key: \"getFeaturesAtPixel\",\n    value: function getFeaturesAtPixel(pixel, options) {\n      var features = [];\n      this.forEachFeatureAtPixel(pixel, function (feature) {\n        features.push(feature);\n      }, options);\n      return features;\n    }\n    /**\n     * Get all layers from all layer groups.\n     * @return {Array<import(\"./layer/Layer.js\").default>} Layers.\n     * @api\n     */\n  }, {\n    key: \"getAllLayers\",\n    value: function getAllLayers() {\n      var layers = [];\n      function addLayersFrom(layerGroup) {\n        layerGroup.forEach(function (layer) {\n          if (layer instanceof LayerGroup) {\n            addLayersFrom(layer.getLayers());\n          } else {\n            layers.push(layer);\n          }\n        });\n      }\n      addLayersFrom(this.getLayers());\n      return layers;\n    }\n    /**\n     * Detect if features intersect a pixel on the viewport. Layers included in the\n     * detection can be configured through the `layerFilter` option.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {AtPixelOptions} [options] Optional options.\n     * @return {boolean} Is there a feature at the given pixel?\n     * @api\n     */\n  }, {\n    key: \"hasFeatureAtPixel\",\n    value: function hasFeatureAtPixel(pixel, options) {\n      if (!this.frameState_ || !this.renderer_) {\n        return false;\n      }\n      var coordinate = this.getCoordinateFromPixelInternal(pixel);\n      options = options !== undefined ? options : {};\n      var layerFilter = options.layerFilter !== undefined ? options.layerFilter : TRUE;\n      var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;\n      var checkWrapped = options.checkWrapped !== false;\n      return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);\n    }\n    /**\n     * Returns the coordinate in user projection for a browser event.\n     * @param {MouseEvent} event Event.\n     * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n     * @api\n     */\n  }, {\n    key: \"getEventCoordinate\",\n    value: function getEventCoordinate(event) {\n      return this.getCoordinateFromPixel(this.getEventPixel(event));\n    }\n    /**\n     * Returns the coordinate in view projection for a browser event.\n     * @param {MouseEvent} event Event.\n     * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n     */\n  }, {\n    key: \"getEventCoordinateInternal\",\n    value: function getEventCoordinateInternal(event) {\n      return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n    }\n    /**\n     * Returns the map pixel position for a browser event relative to the viewport.\n     * @param {UIEvent|{clientX: number, clientY: number}} event Event.\n     * @return {import(\"./pixel.js\").Pixel} Pixel.\n     * @api\n     */\n  }, {\n    key: \"getEventPixel\",\n    value: function getEventPixel(event) {\n      var viewport = this.viewport_;\n      var viewportPosition = viewport.getBoundingClientRect();\n      var viewportSize = this.getSize();\n      var scaleX = viewportPosition.width / viewportSize[0];\n      var scaleY = viewportPosition.height / viewportSize[1];\n      var eventPosition =\n      //FIXME Are we really calling this with a TouchEvent anywhere?\n      'changedTouches' in event ? /** @type {TouchEvent} */event.changedTouches[0] : /** @type {MouseEvent} */event;\n      return [(eventPosition.clientX - viewportPosition.left) / scaleX, (eventPosition.clientY - viewportPosition.top) / scaleY];\n    }\n    /**\n     * Get the target in which this map is rendered.\n     * Note that this returns what is entered as an option or in setTarget:\n     * if that was an element, it returns an element; if a string, it returns that.\n     * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n     *     map is rendered in.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"getTarget\",\n    value: function getTarget() {\n      return (/** @type {HTMLElement|string|undefined} */\n        this.get(MapProperty.TARGET)\n      );\n    }\n    /**\n     * Get the DOM element into which this map is rendered. In contrast to\n     * `getTarget` this method always return an `Element`, or `null` if the\n     * map has no target.\n     * @return {HTMLElement} The element that the map is rendered in.\n     * @api\n     */\n  }, {\n    key: \"getTargetElement\",\n    value: function getTargetElement() {\n      return this.targetElement_;\n    }\n    /**\n     * Get the coordinate for a given pixel.  This returns a coordinate in the\n     * user projection.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n     * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n     * @api\n     */\n  }, {\n    key: \"getCoordinateFromPixel\",\n    value: function getCoordinateFromPixel(pixel) {\n      return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());\n    }\n    /**\n     * Get the coordinate for a given pixel.  This returns a coordinate in the\n     * map view projection.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n     * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n     */\n  }, {\n    key: \"getCoordinateFromPixelInternal\",\n    value: function getCoordinateFromPixelInternal(pixel) {\n      var frameState = this.frameState_;\n      if (!frameState) {\n        return null;\n      }\n      return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n    /**\n     * Get the map controls. Modifying this collection changes the controls\n     * associated with the map.\n     * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n     * @api\n     */\n  }, {\n    key: \"getControls\",\n    value: function getControls() {\n      return this.controls;\n    }\n    /**\n     * Get the map overlays. Modifying this collection changes the overlays\n     * associated with the map.\n     * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n     * @api\n     */\n  }, {\n    key: \"getOverlays\",\n    value: function getOverlays() {\n      return this.overlays_;\n    }\n    /**\n     * Get an overlay by its identifier (the value returned by overlay.getId()).\n     * Note that the index treats string and numeric identifiers as the same. So\n     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n     * @param {string|number} id Overlay identifier.\n     * @return {import(\"./Overlay.js\").default} Overlay.\n     * @api\n     */\n  }, {\n    key: \"getOverlayById\",\n    value: function getOverlayById(id) {\n      var overlay = this.overlayIdIndex_[id.toString()];\n      return overlay !== undefined ? overlay : null;\n    }\n    /**\n     * Get the map interactions. Modifying this collection changes the interactions\n     * associated with the map.\n     *\n     * Interactions are used for e.g. pan, zoom and rotate.\n     * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n     * @api\n     */\n  }, {\n    key: \"getInteractions\",\n    value: function getInteractions() {\n      return this.interactions;\n    }\n    /**\n     * Get the layergroup associated with this map.\n     * @return {LayerGroup} A layer group containing the layers in this map.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"getLayerGroup\",\n    value: function getLayerGroup() {\n      return (/** @type {LayerGroup} */this.get(MapProperty.LAYERGROUP)\n      );\n    }\n    /**\n     * Clear any existing layers and add layers to the map.\n     * @param {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>} layers The layers to be added to the map.\n     * @api\n     */\n  }, {\n    key: \"setLayers\",\n    value: function setLayers(layers) {\n      var group = this.getLayerGroup();\n      if (layers instanceof Collection) {\n        group.setLayers(layers);\n        return;\n      }\n      var collection = group.getLayers();\n      collection.clear();\n      collection.extend(layers);\n    }\n    /**\n     * Get the collection of layers associated with this map.\n     * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n     * @api\n     */\n  }, {\n    key: \"getLayers\",\n    value: function getLayers() {\n      var layers = this.getLayerGroup().getLayers();\n      return layers;\n    }\n    /**\n     * @return {boolean} Layers have sources that are still loading.\n     */\n  }, {\n    key: \"getLoadingOrNotReady\",\n    value: function getLoadingOrNotReady() {\n      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n        var state = layerStatesArray[i];\n        if (!state.visible) {\n          continue;\n        }\n        var renderer = state.layer.getRenderer();\n        if (renderer && !renderer.ready) {\n          return true;\n        }\n        var source = state.layer.getSource();\n        if (source && source.loading) {\n          return true;\n        }\n      }\n      return false;\n    }\n    /**\n     * Get the pixel for a coordinate.  This takes a coordinate in the user\n     * projection and returns the corresponding pixel.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n     * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n     * @api\n     */\n  }, {\n    key: \"getPixelFromCoordinate\",\n    value: function getPixelFromCoordinate(coordinate) {\n      var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());\n      return this.getPixelFromCoordinateInternal(viewCoordinate);\n    }\n    /**\n     * Get the pixel for a coordinate.  This takes a coordinate in the map view\n     * projection and returns the corresponding pixel.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n     * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n     */\n  }, {\n    key: \"getPixelFromCoordinateInternal\",\n    value: function getPixelFromCoordinateInternal(coordinate) {\n      var frameState = this.frameState_;\n      if (!frameState) {\n        return null;\n      }\n      return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n    /**\n     * Get the map renderer.\n     * @return {import(\"./renderer/Map.js\").default|null} Renderer\n     */\n  }, {\n    key: \"getRenderer\",\n    value: function getRenderer() {\n      return this.renderer_;\n    }\n    /**\n     * Get the size of this map.\n     * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return (/** @type {import(\"./size.js\").Size|undefined} */\n        this.get(MapProperty.SIZE)\n      );\n    }\n    /**\n     * Get the view associated with this map. A view manages properties such as\n     * center and resolution.\n     * @return {View} The view that controls this map.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"getView\",\n    value: function getView() {\n      return (/** @type {View} */this.get(MapProperty.VIEW)\n      );\n    }\n    /**\n     * Get the element that serves as the map viewport.\n     * @return {HTMLElement} Viewport.\n     * @api\n     */\n  }, {\n    key: \"getViewport\",\n    value: function getViewport() {\n      return this.viewport_;\n    }\n    /**\n     * Get the element that serves as the container for overlays.  Elements added to\n     * this container will let mousedown and touchstart events through to the map,\n     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n     * events.\n     * @return {!HTMLElement} The map's overlay container.\n     */\n  }, {\n    key: \"getOverlayContainer\",\n    value: function getOverlayContainer() {\n      return this.overlayContainer_;\n    }\n    /**\n     * Get the element that serves as a container for overlays that don't allow\n     * event propagation. Elements added to this container won't let mousedown and\n     * touchstart events through to the map, so clicks and gestures on an overlay\n     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @return {!HTMLElement} The map's overlay container that stops events.\n     */\n  }, {\n    key: \"getOverlayContainerStopEvent\",\n    value: function getOverlayContainerStopEvent() {\n      return this.overlayContainerStopEvent_;\n    }\n    /**\n     * @return {!Document} The document where the map is displayed.\n     */\n  }, {\n    key: \"getOwnerDocument\",\n    value: function getOwnerDocument() {\n      var targetElement = this.getTargetElement();\n      return targetElement ? targetElement.ownerDocument : document;\n    }\n    /**\n     * @param {import(\"./Tile.js\").default} tile Tile.\n     * @param {string} tileSourceKey Tile source key.\n     * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n     * @param {number} tileResolution Tile resolution.\n     * @return {number} Tile priority.\n     */\n  }, {\n    key: \"getTilePriority\",\n    value: function getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n      return _getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);\n    }\n    /**\n     * @param {UIEvent} browserEvent Browser event.\n     * @param {string} [type] Type.\n     */\n  }, {\n    key: \"handleBrowserEvent\",\n    value: function handleBrowserEvent(browserEvent, type) {\n      type = type || browserEvent.type;\n      var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n      this.handleMapBrowserEvent(mapBrowserEvent);\n    }\n    /**\n     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n     */\n  }, {\n    key: \"handleMapBrowserEvent\",\n    value: function handleMapBrowserEvent(mapBrowserEvent) {\n      if (!this.frameState_) {\n        // With no view defined, we cannot translate pixels into geographical\n        // coordinates so interactions cannot be used.\n        return;\n      }\n      var originalEvent = /** @type {PointerEvent} */\n      mapBrowserEvent.originalEvent;\n      var eventType = originalEvent.type;\n      if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {\n        var doc = this.getOwnerDocument();\n        var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;\n        var target = /** @type {Node} */originalEvent.target;\n        if (\n        // Abort if the target is a child of the container for elements whose events are not meant\n        // to be handled by map interactions.\n        this.overlayContainerStopEvent_.contains(target) ||\n        // Abort if the event target is a child of the container that is no longer in the page.\n        // It's possible for the target to no longer be in the page if it has been removed in an\n        // event listener, this might happen in a Control that recreates it's content based on\n        // user interaction either manually or via a render in something like https://reactjs.org/\n        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {\n          return;\n        }\n      }\n      mapBrowserEvent.frameState = this.frameState_;\n      if (this.dispatchEvent(mapBrowserEvent) !== false) {\n        var interactionsArray = this.getInteractions().getArray().slice();\n        for (var i = interactionsArray.length - 1; i >= 0; i--) {\n          var interaction = interactionsArray[i];\n          if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {\n            continue;\n          }\n          var cont = interaction.handleEvent(mapBrowserEvent);\n          if (!cont || mapBrowserEvent.propagationStopped) {\n            break;\n          }\n        }\n      }\n    }\n    /**\n     * @protected\n     */\n  }, {\n    key: \"handlePostRender\",\n    value: function handlePostRender() {\n      var frameState = this.frameState_;\n\n      // Manage the tile queue\n      // Image loads are expensive and a limited resource, so try to use them\n      // efficiently:\n      // * When the view is static we allow a large number of parallel tile loads\n      //   to complete the frame as quickly as possible.\n      // * When animating or interacting, image loads can cause janks, so we reduce\n      //   the maximum number of loads per frame and limit the number of parallel\n      //   tile loads to remain reactive to view changes and to reduce the chance of\n      //   loading tiles that will quickly disappear from view.\n      var tileQueue = this.tileQueue_;\n      if (!tileQueue.isEmpty()) {\n        var maxTotalLoading = this.maxTilesLoading_;\n        var maxNewLoads = maxTotalLoading;\n        if (frameState) {\n          var hints = frameState.viewHints;\n          if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n            var lowOnFrameBudget = Date.now() - frameState.time > 8;\n            maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n            maxNewLoads = lowOnFrameBudget ? 0 : 2;\n          }\n        }\n        if (tileQueue.getTilesLoading() < maxTotalLoading) {\n          tileQueue.reprioritize(); // FIXME only call if view has changed\n          tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n        }\n      }\n      if (frameState && this.renderer_ && !frameState.animate) {\n        if (this.renderComplete_ === true) {\n          if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {\n            this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n          }\n          if (this.loaded_ === false) {\n            this.loaded_ = true;\n            this.dispatchEvent(new MapEvent(MapEventType.LOADEND, this, frameState));\n          }\n        } else if (this.loaded_ === true) {\n          this.loaded_ = false;\n          this.dispatchEvent(new MapEvent(MapEventType.LOADSTART, this, frameState));\n        }\n      }\n      var postRenderFunctions = this.postRenderFunctions_;\n      for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n        postRenderFunctions[i](this, frameState);\n      }\n      postRenderFunctions.length = 0;\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"handleSizeChanged_\",\n    value: function handleSizeChanged_() {\n      if (this.getView() && !this.getView().getAnimating()) {\n        this.getView().resolveConstraints(0);\n      }\n      this.render();\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"handleTargetChanged_\",\n    value: function handleTargetChanged_() {\n      if (this.mapBrowserEventHandler_) {\n        for (var i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {\n          unlistenByKey(this.targetChangeHandlerKeys_[i]);\n        }\n        this.targetChangeHandlerKeys_ = null;\n        this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);\n        this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);\n        this.mapBrowserEventHandler_.dispose();\n        this.mapBrowserEventHandler_ = null;\n        removeNode(this.viewport_);\n      }\n      if (this.targetElement_) {\n        this.resizeObserver_.unobserve(this.targetElement_);\n        var rootNode = this.targetElement_.getRootNode();\n        if (rootNode instanceof ShadowRoot) {\n          this.resizeObserver_.unobserve(rootNode.host);\n        }\n      }\n\n      // target may be undefined, null, a string or an Element.\n      // If it's a string we convert it to an Element before proceeding.\n      // If it's not now an Element we remove the viewport from the DOM.\n      // If it's an Element we append the viewport element to it.\n\n      var target = this.getTarget();\n      var targetElement = typeof target === 'string' ? document.getElementById(target) : target;\n      this.targetElement_ = targetElement;\n      if (!targetElement) {\n        if (this.renderer_) {\n          clearTimeout(this.postRenderTimeoutHandle_);\n          this.postRenderTimeoutHandle_ = undefined;\n          this.postRenderFunctions_.length = 0;\n          this.renderer_.dispose();\n          this.renderer_ = null;\n        }\n        if (this.animationDelayKey_) {\n          cancelAnimationFrame(this.animationDelayKey_);\n          this.animationDelayKey_ = undefined;\n        }\n      } else {\n        targetElement.appendChild(this.viewport_);\n        if (!this.renderer_) {\n          this.renderer_ = new CompositeMapRenderer(this);\n        }\n        this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);\n        for (var key in MapBrowserEventType) {\n          this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));\n        }\n        this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);\n        this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? {\n          passive: false\n        } : false);\n        var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n        this.targetChangeHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)];\n        var _rootNode = targetElement.getRootNode();\n        if (_rootNode instanceof ShadowRoot) {\n          this.resizeObserver_.observe(_rootNode.host);\n        }\n        this.resizeObserver_.observe(targetElement);\n      }\n      this.updateSize();\n      // updateSize calls setSize, so no need to call this.render\n      // ourselves here.\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"handleTileChange_\",\n    value: function handleTileChange_() {\n      this.render();\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"handleViewPropertyChanged_\",\n    value: function handleViewPropertyChanged_() {\n      this.render();\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"handleViewChanged_\",\n    value: function handleViewChanged_() {\n      if (this.viewPropertyListenerKey_) {\n        unlistenByKey(this.viewPropertyListenerKey_);\n        this.viewPropertyListenerKey_ = null;\n      }\n      if (this.viewChangeListenerKey_) {\n        unlistenByKey(this.viewChangeListenerKey_);\n        this.viewChangeListenerKey_ = null;\n      }\n      var view = this.getView();\n      if (view) {\n        this.updateViewportSize_();\n        this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n        this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n        view.resolveConstraints(0);\n      }\n      this.render();\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"handleLayerGroupChanged_\",\n    value: function handleLayerGroupChanged_() {\n      if (this.layerGroupPropertyListenerKeys_) {\n        this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n        this.layerGroupPropertyListenerKeys_ = null;\n      }\n      var layerGroup = this.getLayerGroup();\n      if (layerGroup) {\n        this.handleLayerAdd_(new GroupEvent('addlayer', layerGroup));\n        this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this), listen(layerGroup, 'addlayer', this.handleLayerAdd_, this), listen(layerGroup, 'removelayer', this.handleLayerRemove_, this)];\n      }\n      this.render();\n    }\n    /**\n     * @return {boolean} Is rendered.\n     */\n  }, {\n    key: \"isRendered\",\n    value: function isRendered() {\n      return !!this.frameState_;\n    }\n    /**\n     * @private\n     */\n  }, {\n    key: \"animationDelay_\",\n    value: function animationDelay_() {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_(Date.now());\n    }\n    /**\n     * Requests an immediate render in a synchronous manner.\n     * @api\n     */\n  }, {\n    key: \"renderSync\",\n    value: function renderSync() {\n      if (this.animationDelayKey_) {\n        cancelAnimationFrame(this.animationDelayKey_);\n      }\n      this.animationDelay_();\n    }\n    /**\n     * Redraws all text after new fonts have loaded\n     */\n  }, {\n    key: \"redrawText\",\n    value: function redrawText() {\n      var layerStates = this.getLayerGroup().getLayerStatesArray();\n      for (var i = 0, ii = layerStates.length; i < ii; ++i) {\n        var layer = layerStates[i].layer;\n        if (layer.hasRenderer()) {\n          layer.getRenderer().handleFontsChanged();\n        }\n      }\n    }\n    /**\n     * Request a map rendering (at the next animation frame).\n     * @api\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.renderer_ && this.animationDelayKey_ === undefined) {\n        this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n      }\n    }\n    /**\n     * Remove the given control from the map.\n     * @param {import(\"./control/Control.js\").default} control Control.\n     * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n     *     if the control was not found).\n     * @api\n     */\n  }, {\n    key: \"removeControl\",\n    value: function removeControl(control) {\n      return this.getControls().remove(control);\n    }\n    /**\n     * Remove the given interaction from the map.\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n     * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n     *     undefined if the interaction was not found).\n     * @api\n     */\n  }, {\n    key: \"removeInteraction\",\n    value: function removeInteraction(interaction) {\n      return this.getInteractions().remove(interaction);\n    }\n    /**\n     * Removes the given layer from the map.\n     * @param {import(\"./layer/Base.js\").default} layer Layer.\n     * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n     *     layer was not found).\n     * @api\n     */\n  }, {\n    key: \"removeLayer\",\n    value: function removeLayer(layer) {\n      var layers = this.getLayerGroup().getLayers();\n      return layers.remove(layer);\n    }\n    /**\n     * @param {import(\"./layer/Group.js\").GroupEvent} event The layer remove event.\n     * @private\n     */\n  }, {\n    key: \"handleLayerRemove_\",\n    value: function handleLayerRemove_(event) {\n      removeLayerMapProperty(event.layer);\n    }\n    /**\n     * Remove the given overlay from the map.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n     *     if the overlay was not found).\n     * @api\n     */\n  }, {\n    key: \"removeOverlay\",\n    value: function removeOverlay(overlay) {\n      return this.getOverlays().remove(overlay);\n    }\n    /**\n     * @param {number} time Time.\n     * @private\n     */\n  }, {\n    key: \"renderFrame_\",\n    value: function renderFrame_(time) {\n      var _this2 = this;\n      var size = this.getSize();\n      var view = this.getView();\n      var previousFrameState = this.frameState_;\n      /** @type {?FrameState} */\n      var frameState = null;\n      if (size !== undefined && hasArea(size) && view && view.isDef()) {\n        var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n        var viewState = view.getState();\n        frameState = {\n          animate: false,\n          coordinateToPixelTransform: this.coordinateToPixelTransform_,\n          declutterTree: null,\n          extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),\n          index: this.frameIndex_++,\n          layerIndex: 0,\n          layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n          pixelRatio: this.pixelRatio_,\n          pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n          postRenderFunctions: [],\n          size: size,\n          tileQueue: this.tileQueue_,\n          time: time,\n          usedTiles: {},\n          viewState: viewState,\n          viewHints: viewHints,\n          wantedTiles: {},\n          mapId: getUid(this),\n          renderTargets: {}\n        };\n        if (viewState.nextCenter && viewState.nextResolution) {\n          var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;\n          frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);\n        }\n      }\n      this.frameState_ = frameState;\n      this.renderer_.renderFrame(frameState);\n      if (frameState) {\n        if (frameState.animate) {\n          this.render();\n        }\n        Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n        if (previousFrameState) {\n          var moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equalsExtent(frameState.extent, this.previousExtent_);\n          if (moveStart) {\n            this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n            this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n          }\n        }\n        var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equalsExtent(frameState.extent, this.previousExtent_);\n        if (idle) {\n          this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n          clone(frameState.extent, this.previousExtent_);\n        }\n      }\n      this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n      this.renderComplete_ = this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(RenderEventType.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : undefined;\n      if (!this.postRenderTimeoutHandle_) {\n        this.postRenderTimeoutHandle_ = setTimeout(function () {\n          _this2.postRenderTimeoutHandle_ = undefined;\n          _this2.handlePostRender();\n        }, 0);\n      }\n    }\n    /**\n     * Sets the layergroup of this map.\n     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setLayerGroup\",\n    value: function setLayerGroup(layerGroup) {\n      var oldLayerGroup = this.getLayerGroup();\n      if (oldLayerGroup) {\n        this.handleLayerRemove_(new GroupEvent('removelayer', oldLayerGroup));\n      }\n      this.set(MapProperty.LAYERGROUP, layerGroup);\n    }\n    /**\n     * Set the size of this map.\n     * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setSize\",\n    value: function setSize(size) {\n      this.set(MapProperty.SIZE, size);\n    }\n    /**\n     * Set the target element to render this map into.\n     * @param {HTMLElement|string} [target] The Element or id of the Element\n     *     that the map is rendered in.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setTarget\",\n    value: function setTarget(target) {\n      this.set(MapProperty.TARGET, target);\n    }\n    /**\n     * Set the view for this map.\n     * @param {View|Promise<import(\"./View.js\").ViewOptions>} view The view that controls this map.\n     * It is also possible to pass a promise that resolves to options for constructing a view.  This\n     * alternative allows view properties to be resolved by sources or other components that load\n     * view-related metadata.\n     * @observable\n     * @api\n     */\n  }, {\n    key: \"setView\",\n    value: function setView(view) {\n      if (!view || view instanceof View) {\n        this.set(MapProperty.VIEW, view);\n        return;\n      }\n      this.set(MapProperty.VIEW, new View());\n      var map = this;\n      view.then(function (viewOptions) {\n        map.setView(new View(viewOptions));\n      });\n    }\n    /**\n     * Force a recalculation of the map viewport size.  This should be called when\n     * third-party code changes the size of the map viewport.\n     * @api\n     */\n  }, {\n    key: \"updateSize\",\n    value: function updateSize() {\n      var targetElement = this.getTargetElement();\n      var size = undefined;\n      if (targetElement) {\n        var computedStyle = getComputedStyle(targetElement);\n        var width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);\n        var height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);\n        if (!isNaN(width) && !isNaN(height)) {\n          size = [width, height];\n          if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {\n            warn(\"No map visible because the map container's width or height are 0.\");\n          }\n        }\n      }\n      var oldSize = this.getSize();\n      if (size && (!oldSize || !equals(size, oldSize))) {\n        this.setSize(size);\n        this.updateViewportSize_();\n      }\n    }\n    /**\n     * Recomputes the viewport size and save it on the view object (if any)\n     * @private\n     */\n  }, {\n    key: \"updateViewportSize_\",\n    value: function updateViewportSize_() {\n      var view = this.getView();\n      if (view) {\n        var size = undefined;\n        var computedStyle = getComputedStyle(this.viewport_);\n        if (computedStyle.width && computedStyle.height) {\n          size = [parseInt(computedStyle.width, 10), parseInt(computedStyle.height, 10)];\n        }\n        view.setViewportSize(size);\n      }\n    }\n  }]);\n  return Map;\n}(BaseObject);\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\nfunction createOptionsInternal(options) {\n  /**\n   * @type {HTMLElement|Document}\n   */\n  var keyboardEventTarget = null;\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n\n  /**\n   * @type {Object<string, *>}\n   */\n  var values = {};\n  var layerGroup = options.layers && typeof /** @type {?} */options.layers.getLayers === 'function' ? /** @type {LayerGroup} */options.layers : new LayerGroup({\n    layers: /** @type {Collection<import(\"./layer/Base.js\").default>|Array<import(\"./layer/Base.js\").default>} */\n    options.layers\n  });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n  values[MapProperty.TARGET] = options.target;\n  values[MapProperty.VIEW] = options.view instanceof View ? options.view : new View();\n\n  /** @type {Collection<import(\"./control/Control.js\").default>} */\n  var controls;\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(typeof /** @type {?} */options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n      controls = options.controls;\n    }\n  }\n\n  /** @type {Collection<import(\"./interaction/Interaction\").default>} */\n  var interactions;\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(typeof /** @type {?} */options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n      interactions = options.interactions;\n    }\n  }\n\n  /** @type {Collection<import(\"./Overlay.js\").default>} */\n  var overlays;\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(typeof /** @type {?} */options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n}\nexport default Map;","map":null,"metadata":{},"sourceType":"module"}